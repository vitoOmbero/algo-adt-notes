# Определение Алгоритма

**Алгоритм**  -  описание  последовательности  действий,  строгое  выполнение  которых приводит к решению поставленной задачи за конечное число шагов. Программа - запись алгоритма на формальном языке. Алгоритм определяет функцию (отображение) **F : X → Y.**
*X* – множество исходных данных, *Y* – множество значений.


# Свойства

 **Дискретность**. Алгоритм исполняется по шагам: каждое действие, предусмотренное алгоритмом, исполняется только после того, как закончилось исполнение предыдущего; в последующих шагах используются результаты из предыдущих.

 **Детерминированность**.  Каждый шаг алгоритма строго определён.

 **Конечность**.  Алгоритм  должен  заканчиваться  после  конечного  числа  шагов для любого множества данных,  причем число  шагов  является  критическим  параметром,  определяющим  эффективность  и сложность алгоритма. 

 **Массовость**. Алгоритм решения задачи всегда разрабатывается в общем виде, поэтому он  должен  быть  применим  для  некоторого  класса  задач,  различающихся  только исходными  данными.  При  этом  исходные  данные  могут  выбираться  из  некоторой области, которая называется областью применимости алгоритма.

 **Результативность**. Это свойство подразумевает,  что  каждый шаг и алгоритм в целом после  своего  порождает  результат,  в  котором  все  имеющиеся  объекты  однозначно определены.  Если  это  по  каким  -  либо  причинам  невозможно,  то  алгоритм  должен сообщать, что решение задачи не существует.

 **Эффективность**. Алгоритм для своего исполнения требует от исполнителя некоторых ресурсов, количество которых практически всегда ограничено.

Эффективность алгоритма определяется:

- Временем работы,
- Объемом дополнительно используемой памяти,
- Другими характеристики. Например, количеством операций сравнения или количеством обращений к диску.

**Ввод** и **Вывод**. Алгоритм может принимать и возвращать наборы данных, которые обычно являются связанными (логически; в структуру данных). Алгоритм решает задачу, которая формулируется как минимум требованиями к набору данных на выходе. Разные решения задачи приводят к разным алгоритмам, которые *могут* использовать в ходе решения задачи *различные* стуктуры данных. 

# Сложность

*Комбинационная* сложность - минимальное число элементов для реализации алгоритма в виде вычислительного устройства.
*Описательная* сложность - длина описания алгоритма на формальном языке
*Вычислительная* сложность - количество элементарных операций, исполняемых алгоритмом для неких входных данных.

 *Временная* сложность  алгоритма - это один  из критериев оценки алгоритма. Под ней понимается  зависимость  итераций  алгоритма  от  размера  входных  данных. Определяется функцией T(n), где n это количество входных данных (могут характеризоваться несколькими числами).
 *Асимптотическую* сложность алгоритма оценивают по порядку роста функции времени T(n).  Алгоритм  имеет  сложность  O(f(n)),  если  при  увеличении  размерности  входных данных n, время выполнения алгоритма возрастает с той же скоростью, что и функция f(n).  При  работе  с  матрицей  *n  x  n*  во  время  каждой  из  n  итераций  внешнего  цикла, внутренний  цикл  тоже  выполняется  n  раз.  Общее  количество  итераций  внутреннего цикла  равно  n⋅n.  Это  определяет  сложность  алгоритма  как  O(n^2).  Оценивая  порядок сложности алгоритма, используют только ту часть, которая возрастает быстрее всего. Предположим,  что  рабочий  цикл  описывается  выражением  n^3+n.  В  таком  случае  его сложность будет равна O(n^3). Рассмотрение быстро растущей части функции позволяет оценить поведение алгоритма при увеличении n. Например, при n=100, разница между n^3+n=1000100  и  n^3=1000000  равна  всего  лишь  100,  что  составляет  0,01%.  При вычислении O можно не учитывать постоянные множители в выражениях. Алгоритм с временной  сложностью  3⋅n^3  имеет  асимптотическую  сложность  O(n^3).  Это  делает зависимость отношения O(n) от изменения размера задачи более очевидной.
 Временная сложность может быть константой или описываться функциями: O(n), O(log n), O(n log n), O(n2), O(n^3), 2n.
 Объем дополнительной памяти - M(n).

Типовые оценки сложности:

 - O(log n) – время выполнения описывается логарифмической зависимостью. Такое время выполнения имеет бинарное дерево поиска.
 - O(n⋅log n) – время выполнения равно n⋅log n (linearithmic algorithm) имеет алгоритм быстрой сортировки;
 - O(n^2) – время выполнения является квадратичным у алгоритма сортировки пузырьком;
 - O(n^3) – кубическое время выполнение имеет алгоритм с циклом тройного уровня
вложения;
 - 2^n – задача коммивояжёра и алгоритмы полного перебора имеет экспоненциальное временем выполнением.


# Примеры

## Найти n-ое число Фибоначчи.

F(0) = 1; F(1) = 1;
F(n) = F(n – 1) + F(n – 2);
1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, …
Есть рекурсивный и нерекурсивный алгоритмы.

```c++
// Рекурсивный алгоритм.
int Fibonacci1( int n )
{
    if( n == 0 || n == 1 ) {
        return 1;
    }
    return Fibonacci1( n – 1 ) + Fibonacci1( n – 2 );
}

// Нерекурсивный алгоритм.
int Fibonacci2( int n )
{
    if (n == 0) {
        return 1;
    }
    int prev = 1; // F(0).
    int current = 1; // F(1).
    for ( int i = 2; i <= n; ++i ) 
    {
        int temp = current;
        current += prev; // Вычисление F(i).
        prev = temp; // Запоминаем F(i-1).
    }
    return current;
}

```

## Является ли заданное натуральное число n простым.

ожем быстро определять, делится ли одно
натуральное число (n) на другое (k), проверив
остаток от деления:
n % k == 0
Будем перебирать все числа от 1 до sqrt(n), проверяя, делит ли какое-нибудь из них n.

```c++
bool IsPrime( int n )
{
    if( n == 1 ) {
        return false;
    }
    for( int i = 2; i * i <= n; ++i ) 
    {
        if( n % i == 0 ) {
            return false;
        }
    }
    return true;
}
```

Время работы T(n = O(sqrt(n))
M(n) = O(1)

Тест Агравала - Каяла - Саксены (2011)
T(n) = O(log^3(n))


## Быстрое возведение в степень

Дано число a и неотрицательное целое число n.
Найти a^n.

Тривиальный алгоритм (перемножение a в количестве n-1 раз):
T(n) = O(n)

Идея: a^2^k = ((a^2)^2)...^2 (k раз)

если n = 2^k1 + 2^k2 + ... + 2^ks, k1..ks - различны, то

a^n = a^2^k1 * a^2^k2 * ... * a^2^ks

```c++
double Power( double a, int n )
{
    double result = 1; // Для хранения результата.
    double aInPowerOf2 = a; // Текущее значение ((a^2)^2…)^2
    while( n > 0 ) 
    {
        // Добавляем нужную степень двойки к результату,
        // если она есть в разложении n.
        if( n & 1 == 1 ) {
            result *= aInPowerOf2;
        }
        aInPowerOf2 *= aInPowerOf2;
        n = n >> 1; // Можно писать n /= 2.
    }
    return result;
}
```

Количество итераций цикла = степень двойки, не превышающая n, т.е. log(n).
Каждая итерация цикла требует ограниченное количество операций, O(1).
Доп. память не используется.
T(n) = O(log n),
M(n) = O(1).


# Определение Абстрактного Типа Данных

**Абстрактный тип данных** - спецификация интерфейса с методами, которые описываются в виде требований.

**Структура данных** - алгоритмическая реализация абстрактоного типа данных для обработки связанных данных.

*Коллекции C#, Контейнеры С++* - программные реализации структур данных.

Типичные операции над структурами:

- добавление данных,
- изменение данных,
- удаление данных,
- поиск данных.


## Абстракция Стек

Одна из удобных абстракций - стек. Он должен предоставлять нам методы:

- *create* -- создание стека. Может быть, потребуется аргумент, определяющий максимальный размер стека.
- *push* -- занесение элемента в стек. Размер стека увеличивается на единицу. Занесённый элемент становится вершиной стека.
- *pop* -- извлечь элемент, являющийся вершиной стека и уменьшить размер стека на единицу. Если стек пуст, то значение операции не определено.
- *peek* -- получить значение элемента, находящегося на вершине стека, не изменяя стека. Если стек пуст, значение операции не определено.
- *empty* -- предикат истинен, когда стек пуст.
- *destroy* -- уничтожить стек.


## Абстракция множество

Множество есть совокупность однотипных элементов, на которых определена операция сравнения.
Обозначение: списком значений внутри фигурных скобок.
Пустое множество: s = {}.

- insert -- добавление элемента в множество.
{1,2,3}.insert(5) -> {1,2,3,5}
{1,2,3}.insert{2} -> {1,2,3}
- remove -- удалить элемент из множества.
{1,2,3}.remove(3) -> {1,2}
{1,2,3}.remove(5) -> не определено.
- in -- определить принадлежность множеству.
{1,2,3}.in(2) -> true
{1,2,3}.in(5) -> false
- size -- определить количество элементов в множестве





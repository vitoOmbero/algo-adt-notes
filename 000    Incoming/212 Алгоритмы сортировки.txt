Алгоритмы  сортировки  оцениваются  по  скорости  выполнения  и  эффективности 
использования памяти. 

Время — основной параметр, характеризующий быстродействие алгоритма. Поэтому параметру алгоритмы сортировки делятся на худшее, среднее и лучшее поведение. Для типичного алгоритма хороший показатель степени сложности – это O(n log n) и плохой — это O(n2). Средний показатель степени сложности — O(n). Алгоритмы сортировки, использующие операцию сравнения 
значений и нуждаются по меньшей мере в Ω(n log n) сравнениях. Тем не менее, существует алгоритм сортировки Хана (Yijie Han), к примеру, с вычислительной сложностью O(n log log n log log log n). Реализация его чрезмерно сложна, а за О-
нотацией скрывается весьма большой коэффициент, что делает невозможным его применение в повседневной практике. Также существует понятие сортирующих сетей. Предполагая, что можно одновременно (например, при параллельном 
вычислении) проводить несколько сравнений, можно отсортировать n чисел за O(log2 n) операций. При этом число n должно быть заранее известно; 

Самые быстрые алгоритмы для одного и двух элементов.

void sort_1(int *a) { 
    return; 
} 
void sort_2(int *a) { 
    if (a[1] < a[0]) { 
      swap(a[1], a[0]); 
    } 
}




Память — ряд алгоритмов требует выделения дополнительной памяти под временное хранение данных. Как правило, эти алгоритмы требуют O(log n) памяти. При оценке не учитывается место, которое занимает исходный массив и независящие от входной последовательности затраты, например, на хранение кода программы (так как всё это имеет степень роста O(1)). Алгоритмы сортировки, не использующие дополнительной памяти, называются сортировками на месте.


Наиболее распространёнными среди алгоритмов сортировки считаются:
• Сортировка пузырьком.
• Сортировка вставками.
• Сортировка выбором.
• Сортировка слиянием.
• Сортировка Шелла.
• Быстрая сортировка.

Сортировка пузырьком

Алгоритм сортировки пузырьком – это простой алгоритм сортировки, который выполняя проходы
по массиву элементов, каждый раз перемещает наибольший элемент в его конец.

❖ Массив делится на две части, упорядоченную - левую и неупорядоченную - правую
❖ На каждой итерации проходим правую часть сравнивая текущий элемент с соседом слева
❖ Меняем элементы местами если сосед больше
❖ Иначе, уменьшаем индекс текущего на 1
❖ Наименьший элемент всплывает к границе левой части
❖ Останавливаемся если не было ни одного обмена
❖ Массив из n элементов требует максимум n-1 итерацию

212-03

• Лучший случай
• 1 проход, N-1 сравнение, О обменов => O(N)
Худший случай
• N-1 проход, N(N-1)/2 сравнений, N-1 обменов => 0(N^2)

1 Количество перестановок N элементов: N!
1 сравнение = 1 бит информации
Для записи номера перестановки нужно
log2(N!) = N log(N) бит

Сложность алгоритма 
Лучший вариант Средний вариант Худший вариант
Степень сложности О(n) О(n2) О(n2)
Рост памяти О(1) О(1) О(1)


Сортировка вставками

Массив делится на две части, упорядоченную - левую и неупорядоченную - правую
На каждой итерации выбираем элемент из правой части и вставляем его на подходящее место в левой части
Выбор очередного элемента из исходного осуществляется произвольно. 
Часто применяемый на малых объёмах данных.
Массив из n элементов требует n-1 итерацию.

212-02

Сложность алгоритма 
Лучший вариант Средний вариант Худший вариант
Степень сложности О(n) О(n2) О(n2)
Рост памяти О(1) О(1) О(1)

void insertion_sort(int *a, int n) { 
  for (int i = 1; i < n; ++i) {  
    int tmp = a[i]; 
    for (int j = i; j > 0 && tmp < a[j-1]; --j) { 
      a[j] = a[j-1]; 
    } 
    a[j] = tmp; 
   } 
}

Лучший случай: ➔ O(n)
❖ Массив упорядочен по возрастанию
❖ Внутренний цикл сделает 0 итераций
❖ Количество копирований: 2*(n-1)  ➔ O(n)
❖ Количество сравнений: (n-1)  ➔ O(n)
Худший случай:          ➔ O(n2)
❖ Массив упорядочен в порядке убывания:
❖ Внутренний цикл работает i-1 итерацию, для i = 2,3, …, n
❖ Количество копирований: 2*(n-1)+(1+2+...+n-1)= 2*(n-1)+ n*(n-1)/2  ➔ O(n2)
❖ Количество сравнений: (1+2+...+n-1)= n*(n-1)/2  ➔ O(n2)
В среднем:    ➔ O(n2)


Сортировка выбором

Сортировка выбором – алгоритм сортировки, который на каждом своем шаге отыскивает
наименьший элемент в неотсортированной части массива и устанавливает его в соответствующую
позицию массива.
Этапы сортировки:
 - Разделим массив на две части: левую - упорядоченную и правую – неупорядоченную
 - Будем гарантировать, что элементы в правой части больше чем в левой
 - Нахождение минимального значения в массиве, в правой, неупорядоченной, части.
 - Обмен этого значения со значением первой неотсортированной позиции (обмен не нужен,
если минимальный элемент уже находится на данной позиции).
 - Сортировка остальных элементов списка, исключив из рассмотрения уже отсортированные:  После каждого выбора и перестановки, будем смещать 
границу между частями массива на 1 вправо.

Выбор каждого нового элемента требует прохода по правой части
Для сортировки массива из N элементов требуется N-1 проход

212-01

Сложность алгоритма 
Лучший вариант Средний вариант Худший вариант
Степень сложности О(n) О(n2) О(n2)
Рост памяти О(1) О(1) О(1)

void selection_sort(int *a, int n) { 
  for (int i = 0; i < n - 1; ++i) { 
    int min_index = i; 
    for (int j = i + 1; j < n; ++j) { 
       if (a[j] < a[min_index]) min_index = j; 
    } 
    swap(a[i], a[min_index]); 
  } 
} 
void swap(int &a, int &b ) { 
  int tmp = a; 
  a = b; 
  b = tmp; 
}

Анализ:

• В общем случае алгоритм сортировки состоит из сравнения ключей и перестановки элементов
• Время работы алгоритма пропорционально количеству сравнений и количеству перестановок
• Внешний цикл совершает n-1 итерацию
• В каждой итерации 1 перестановка
• в 1й итерации n-1 сравнение, во 2й – n-2, ... в n-1й – 1
• Ровно n(n - 1)/2 сравнений
• Ровно n-1 перемещений


Улучшенная сортировка вставками

Сортировка вставками. n(log(n)) ?

❖ Будем искать позицию вставки в упорядоченную часть массива бинарным поиском 
❖ O(n log(n)) - операций сравнения 
❖ O(n^2) – операций перемещения 
❖ Используем memmove для уменьшения константы C2 
❖ Tn ≤ C1 n log(n) + C2 n^2

void memmove(char *dst, char *src, int size); 
void insertionSortFast(int *a, int n) { 
  for (int i = 1; i < n; ++i) {  
    int new_pos = binary_search(a, i, a[i]); 
    
    if (new_pos < i) { 
      int tmp = a[i]; 
      memmove(&a[new_pos + 1], &a[new_pos],(i - new_pos)*sizeof(int)); 
      a[new_pos] = tmp; 
    } 
   } 
}

❖Будем искать позицию вставки за время O(log(i − k))
❖O(n log(n)) , θ(n) - операций сравнения
❖O(n2), θ(1) - операций перемещения



Хорошие сортировки

Пирамидальная сортировка

N вставок в кучу: N • O(log(N))
N Извлечение минимума из кучи: N • O(log(n))
Построение кучи из N элементов: O(N•log(N))

212-04

void heap_insert(int *a, int n, int x) 
{ 
  a[n+1] = x; 
  for (int i = n+1; i > 1;) { 
    if (a[i] > a[i/2]) { 
      swap(a[i], a[i/2]); 
      i = i/2; 
    } else { 
      break; 
    } 
  } 
}

212-05

void heap_pop(int *a, int n) { 
  swap(a[n],a[1]); 
   
  for (int i = 1; 2*i < n;) { 
    i *= 2; 
    if (i+1 < n && a[i] < a[i+1]) { 
      i += 1; 
    } 
    if (a[i/2] < a[i]) { 
      swap(a[i/2], a[i]); 
    } 
  } 
}

212-06

void heap_sort(int *data, int n) { 
  int *buff = new int[n+1]; 
  for (int i = 0; i < n; ++i) { 
    heap_insert(buff, i, data[i]); 
  } 
  for (int i = 0; i < n; ++i) { 
    data[n-1-i] = buff[1]; 
    heap_pop(buff, n - i); 
  } 
  delete [] buff; 
}

❖ Построить пирамиду за линейное время: O(N)
❖ N раз достать максимальный элемент: O(N•log(N))
❖ Не использовать дополнительную память

Пирамидальная за линейное время
❖ Для внутренних элементов восстановить порядок
❖ По 2 сравнения на уровень дерева N/2 • 2 

212-07

void heap_make(int *a, int n) { 
  for (int i = n/2; i >= 1; --i) { 
    for (int j = i; j <= n/2;) { 
      int k = j*2; 
      if (k+1 <= n and a[k] < a[k+1]) { 
        ++k; 
      } 
      if (a[j] < a[k]) { 
        swap(a[k],a[j]); 
        j = k; 
      } else { 
        break; 
      } 
    } 
  } 
}

void heap_sort_fast(int *data, int n) { 
  heap_make(data - 1, n); 
  for (int i = 0; i < n; ++i) { 
    heap_pop(data - 1, n - i); 
  } 
}


Пирамидальная сортировка как эволюция сортировки выбором
212-08


Сортировка слиянием

Сортировка слиянием – алгоритм сортировки который упорядочивает массив в определённом
порядке. Реализует принцип «разделяй и властвуй», сначала массив разбивается на части, после
чего каждая часть сортируется отдельно и объединяется в общее решение.
Этапы сортировки:
1. Массив разбивается на два подмассива примерно одинакового размера. Рекурсивное
разбиение массива на подмассивы происходит до тех пор, пока размер подмассива не
достигнет единицы (любой массив длины 1 можно считать упорядоченным).
2. Каждая из частей сортируется отдельно.
3. Два упорядоченные подмассивы соединяются в один.

* Выберем массив, крайний элемент которого меньше
Извлечем этот элемент в массив-результат
* Продолжаем, пока один из массивов не опустеет
* Копируем остаток второго массива в конец массива-результата

Сложность алгоритма 
Лучший вариант Средний вариант Худший вариант
Степень сложности О(n log n) О(n log n ) О(n log n)
Рост памяти О(n) О(n) О(n)

void merge(int *a, int a_len, int *b, int b_len, int *c) {
int i=0; int j=0;
for (;i<a_len and j < b_len;) {
if (a[i] <b[j]) {
c[i+j] = a[i];
++i;
} else {
c[i+j] = b[i];
++j;
}
}
if (i= a_len) {
for (; j < b_len; ++i) { c[i+j] = b[j]; }
} else {
for (;i < a_len;++i) { c[i+j] = a[i]; }
}
}

Сложность O(n+m)
Количство сравнений
• Лучшее: min(n,m)
Худшее n+m

Нисходящая сортировка слиянием

Разбить массив на 2 части
Отсортировать каждую часть рекурсивно
Объединить 1 и 2 части
212-09

void merge_sort(int *data, int size, int *buffer) {
if (size < 2) return;
merge_sort (data, size / 2, buffer);
merge_sort(&data[size / 2], size - size / 2, buffer);
merge (&data[0], size / 2, &data[size/2], size - size / 2, buffer);
for (size_t pos = 0; pos < size; ++ pos) {
data[pos]  = buffer[pos];
}
}

Восходящая сортировка слиянием
Разбить массив на 2^k частей размером не больше m.
Отсортировать каждую часть другим алгоритмом
Объединить 1 и 2, 3 и 4, ... n-1 и n части.
Повторить шаг 3, пока не останется одна часть
212-10

void merge_sort(int *data, size_t size, int *buffer) {
for (size_t chunk_size = 1; chunk_size < size; chunk_size *= 2) {
size_t offset = 0;
for (; offset + chunk_size < size; offset += 2 * chunk_size) {
size_t right_size = chunk_size;
if (offset + chunk_size + right_size > size) {
right_size = size - offset - chunk_size;
}
merge(
&data[offset], chunk_size,
&data[offset + chunk_size], right_size,
&buffer[offset]);
}
for (size_t pos = 0; pos < size; ++pos) {
data[pos] = buffer[pos];
}
}
}


void merge_sort_fast(int *data, size_t size, int *buffer) {
bool is_swapped = false;
for(size_t chunk_size = 1; chunk_size < size; chunk_size *= 2, is_swapped = !is_swapped) {
size_t offset = 0;
for (;offset + chunk_size < size; offset += 2 * chunk_size) {
size_t right_size = chunk_size;
if (offset + chunk_size + right_size > size) {
right_size = size - offset - chunk_size;
}
merge
&data offset), chunk_size,
&data[offset + chunk_size], right_size,
&buffer[offset]);
}
for (size_t pos = offset; pos< size; ++pos) {
buffer[pos] = data[pos];
}
std::swap(data, buffer);
}
if (is_swapped) {
std:: swap(data, buffer);
for(size_t pos = 0; pos < size; ++pos) {
data[pos] - buffer[pos];
}
}
}

К-путевое слияние
Дано k упорядоченных массивов суммарным размером n: A1, A2, .. Ak
* Построить кучу из k массивов О(k)
з Перенести первый элемент из вершины кучи в результат О(1)
* Если массив на вершине кучи пуст – извлечь элемент из кучи
з Восстановить порядок массивов в куче о(log(k))
* Повторить пока куча не пуста
Суммарная сложность: 0(k + n*log(k))
212-11

Экономия на операциях копирования: n
Количество сравнений такое же как и при log(k) 2х путевых слияниях
212-12


 Сортировка Шелла (Shell sort) — алгоритм сортировки, являющийся усовершенствованным вариантом сортировки вставками. Идея метода Шелла состоит в сравнении элементов, стоящих не только рядом, но и на определённом расстоянии друг от друга. Иными словами — это сортировка вставками с предварительными «грубыми» проходами. Аналогичный метод усовершенствования пузырьковой сортировки называется сортировка расчёской.

При сортировке Шелла сначала сравниваются и сортируются между собой значения, стоящие один от другого на некотором расстоянии d. После этого процедура повторяется для меньших значений d, а завершается сортировка Шелла упорядочиванием элементов при d=1 (то есть обычной сортировка вставками). 
Эффективность сортировки Шелла в определённых случаях обеспечивается тем, что элементы «быстрее» встают на свои места (в простых методах сортировки, например, пузырьковой, каждая перестановка двух элементов уменьшает количество инверсий в списке максимум на 1, а при сортировке Шелла это число может быть больше). Невзирая на то, что сортировка Шелла во многих случаях медленнее, чем быстрая сортировка, она имеет ряд преимуществ: 
  отсутствие потребности в памяти под стек; 
  отсутствие деградации при неудачных наборах данных — быстрая сортировка легко деградирует до O(n²), что хуже, чем худшее гарантированное время для сортировки Шелла.

Быстрая сортировка

Быстрая сортировка – алгоритм сортировки, который является наиболее быстрым из известных
методов сортировки массива со степенью роста сложности О(n log n).
Этапы сортировки:
• Случайный выбор опорного элемента массива (pivotValue), относительно которого переупорядочиваются элементы массива.
• Переместить все значения которые больше опорного вправо, а все значения что меньше опорного влево.
• Повторить алгоритм для неотсортированной левой и правой части массива, пока каждый элемент не окажется на своей позиции.
Сложность алгоритма 

Лучший Средний Худший 
Степень сложности О(n log n) О(n log n ) О(n2)
Рост памяти О(1) О(1) О(1)

212-13

Сортировка Хоара
void quick_sort(int *a, int n) {
int i = 0;
int j = n - 1;
bool side = 0;
while (i != j) {
if (a[i] > a[j]) {
swap (a[i], a[j]);
side = !side;
}
if (side)
++i;
} else {
--j;
}
}
if (i > 1) quick_sort (a, i);
if (n > i+1) quick_sort (a + (i+1), n - (i+1));
}

• Предположим, что split делит массив в соотношении 1:1
• Т(n) <= с_1 + c_2 * n + T(n/2) + T(n/2) =
Sum|k=0..log2(n)|{с_1 * 2^k + c_2*n} = с_1 * n + с_2 * n log(n)
• Т(n) = O(n log(n))


Упорядоченный массив делится в соотношении 1:n-1
Т(n) = с_1 + с_2 * n + T(n – 1) = 1/2*c_2*n^2 + c_1*n = O(n^2)

212-14

Quicksort: выбор пивота
1й элемент
Серединный элемент
Медиана трёх
Случайный элемент
Медиана
Медиана по трём случайным

Quicksort-killer

Последовательность, приводящая к времени: T(n) =  O(n^2)
[1,2,3,...n) <=> первый элемент
Для любого предопределённого порядка выбора
пивота, существует kіllег-последовательность
212-15

Рандомизованная медиана
Медиана – RandSelect(A[1, N], k); k = N/2
Случайно выберем элемент из A: A[j]
Разобьём А на 2 части: меньше/больше A[j]
Пусть позиция A[j] в разделённом массиве: k
k<ј ?
• Найдём: RandSelect(A[1, j], k)
•Иначе: RandSelect(A[j+1, N], k-j)

медиана за линейное время
212-16

Медиана за линейное время: анализ
• Разобьём массив на пятёрки
Отсортируем каждую пятёрку с_1 N
• Найдём медиану середин пятёрок T(N/5)
• Разобьём массив на 2 группы <> медианы медиан: c_2 N
• найдём: SECLECT(A[1,j], k) => Т(j)
• иначе: SELECT(A[j+1, N], k-j) => T(N – ј); 0.3N <= j <= 0.7N;
T(N) <= T(N/S) + cN + T(0.7N); => T(N) = O(N);

Сортировки безх сравнений
1. Сортировка подсчетом
2. Поразрядная сортировка от младших к старшим
3. Поразрядная сортировка от старших к младшим
4. Поразрядная быстрая сортировка

Сортировка подсчетом

212-17

void count_sort(int *data, int size, int range) {
int *count - new int[range];
int *aux - new int[size];

for (int i = 1; i < range; ++i) {
  count[i] = 0;
}
for (int i = 0; i < size; ++i) {
  ++count[data[i] + 1];
}
for (int i = 1; i < range; ++i) {
  count[i] += count[i - 1];
}
for (int i = 0; i < size; ++i) {
  aux [count[data[i]]++] = data[i];
}
for (int i = 0; i < size; i++) {
  data[i] = aux[i];
}
delete [] aux;
delete [] count;
}

Algorithm 3.11: LSDRadixSort(R)
Input: Set R = {S1, S2, ..., Sn} of strings of length m over the alphabet (O..o).
Output: R in increasing lexicographical order.
(1) for e-m-1 to o do Counting Sort(R,)
(2) return R
(просто ссылка)

+ O(n) - linear time
+ stable
+ нет сравнений
- требует O(n) памяти
- O(n) перемещений

LSD raddix sort
212-18

void jsw_radix_pass ( int a[], int aux[], int n, int radix )
{
int i;
int count[RANGE] = {0};

for (i = 0; i<n; i++)
  ++count[digit (a[i], radix ) + 1];
for (i = 1; i < RANGE; i++)
  count[i] +- countſi - 1];
for (i = 0; i <n; i++)
  aux[count digit (ali), radix ) ]++) = a[i];
for (i = 0; i<n; i++)
  a[i] = aux[i];
}

+ O(n*key len) время работы
+ O(n) время работы
+ stable
- can't use unstable sort for buckets

Algorithm 3.15: MSDRadixSort(R, L)
Input: Set R = {S1, S2, ..., Sn} of strings over the alphabet [O...o)
and the length of their common prefix.
Output: R in increasing lexicographical order.
(1) if |R|<o then return StringQuicksort(R, 1)
(2) RISER ||SI = l}; R=R\R
(3) (Ro, Ri,..., Ro-1) - Counting Sort(R, 1)
(4) for it to o -1 do Ri MSDRadix Sort(R,l + 1)
(5) return RiRo Ri... R.-1
(просто ссылка)


+ O(n*key_len) время работы*
+ O(n) памяти
+ нет сортировки частей размером 1
+ could be unstable
- рекурсивная реализация

MSD vs LSD
212-20

MSD sort vs Quicksort
первый бит == 1 как опорный элемент

Binary Quicksort

quicksortB(int a[], int i, int r, int w)
{ int i = 1, j = r;
if (r <= 1 || w > bitsword) return;
while (j = i)
{
while (digit(a[i], w) == 0 && (i < ))) i++;
while (digit(a[j], w) == 1 && (j > i)) ;--;
exch (a[i], a[j]);
}
if (digit(a[r], w) == 0) j++;
quicksortB(a, i, j-1, w+1);
quicksortB(a, j, r, w+1);
}

3-way split
212-21

3-way raddix quick sort

#define ch(A) digit(A, D)

void quicksortX (Item a[], int l, int r, int D)
{
  int i, j, k, p, q; int v;
  if (r-1 <= M) { insertion (a, 1, r); return;}
  v = ch(a[r]); i = l-1; j=r; p = l-1; q = r;
  while (i<j)
  {
    while (ch(a[++i]) <v);
    while (v < ch(a[--j])) if (j == 1) break;
    if (i>j) break;
    exch(a[i], [j]);
    if (ch(a[i]) == v) ( p++; exch(a[p], a[i]); }
    if (v==ch (a[j])) (q--; exch(a[j], a[q]); }
  }
  if (p == q)
    {if (v != '\0') quicksortX (a, l, r, D+l);
  return;}
  if (ch(a[i]) <v) i++;
  for (k = 1; K <= p; k++, j--) exch(a[k], a[j]);
  for (k = r; k >= q; k--, i++) exch(a[k], a[i]);
  quicksortX(a, l, j, D);
  if ((i == r) && (ch(a[i]) = v)) i++;
  if (v != '\0') quicksortX(a, j+1, i-1, D+1)
  quicksortX(a, i, r, D);
}

212-22



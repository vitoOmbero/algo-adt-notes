Дерево (свободное) - непустая коллекция вершин и ребер, удовлетворяющих определяющему свойству дерева.
Вершина (узел) - простой объект, который может содержать некоторую информацию.
Ребро – связь между двумя вершинами.
Путь в дереве - список отдельных вершин, в котором следующие друг за другом вершины соединяются ребрами дерева.
Определяющее свойство дерева – существование только одного пути, соединяющего любые два узла.

Дерево (свободное) - неориентированный связный граф без циклов.
Дерево с корнем - дерево, в котором один узел выделен и назначен «корнем» дерева.
Существует только один путь между корнем и каждым из других узлов дерева.

Высота (глубина) дерева с корнем - количество вершин в самом длинном пути от корня.
Обычно дерево с корнем рисуют с корнем, расположенным сверху. 

Каждый узел (за исключением корня) имеет только один узел, расположенный над ним. Такой узел называется родительским.
Узлы, расположенные непосредственно под данным узлом, называются его дочерними узлами.
Узлы, не имеющие дочерних узлов называются листьями. Любое дерево с корнем содержит листовую вершину.
Дерево из n вершин содержит n-1 ребро.

Двоичное дерево — древовидная структура данных, в которой каждый узел имеет не более двух потомков (детей). В такой структуре первый узел называется родительским узлом, а дети называются левым и правым потомками соответственно.  
N-арное дерево - в котором степени вершин не превосходят N+1. Каждая вершина имеет не более N дочерних вершин.

// Узел двоичного дерева с данными типа int.
struct CBinaryNode {
int Data;
свinaryNode* Left; // NULL, если нет.
CBinaryNode* Right; NULL, если нет.
свinaryNode* Parent; NULL, если корень.
};
// Узел дерева с произвольным ветвлением.
struct CTreeNode {
int Data;
cTreeNode* Next; // NULL, если нет следующих.
cTreeNode* First; // NULL, если нет дочерних.
cTreeNode* Parent; // NULL, если корень.
};

Пошаговый перебор элементов дерева по связям между узлами-предками и узлами-потомками называется обходом дерева.
Обходом двоичного дерева в глубину (DFS) называется процедура, выполняющая в некотором заданном порядке следующие действия с поддеревом:
- просмотр (обработка) узла-корня поддерева,
- рекурсивный обход левого поддерева,
- рекурсивный обход правого поддерева.
DFS - Depth First Search

Прямой обход (сверху вниз, pre-order).

209-07

Вначале обрабатывается
узел, затем посещается левое и правые поддеревья.
Порядок обработки узлов дерева на рисунке:
Е, D, В, А, С, Н, Е, G.
Обратный обход (снизу вверх, post-order). Вначале посещаются
левое и правое поддеревья, а затем обрабатывается узел.
Порядок обработки узлов дерева на рисунке:
А, С, В, D, G, F, Н, Е.
Поперечный обход (слева направо, in-order). Вначале
посещается левое поддерево, затем узел и правое
поддерево.
Порядок обработки узлов дерева на рисунке:
A, B, C, D, E, F, G, H.

// Обратный обход в глубину.
void TraverseDFS ( CBinaryNode* node )
{
if( node -- )
return;
TraverseDF5( node->Left );
TraverseDFS( node->Right );
visit( node );
};

Задача. Вычислить количество вершин в дереве.
Решение. Обойти дерево в глубину в обратном порядке.
После обработки левого и правого поддеревьев
вычисляется число вершин в текущем поддереве.
Реализация:
//Возвращает количество элементов в поддереве.
int Count( CBinaryNode* node )
{
if( node == 0 )
return 0;
return Count( node->Left) + Count( node->Right) + 1;
};


• Обход в глубину не начинает обработку других
поддеревьев, пока полностью не обработает
текущее поддерево.
Для прохода по слоям в прямом или обратном
порядке требуется другой алгоритм.


Определение 12. Обход двоичного дерева в ширину
(BRS) — обход вершин дерева по уровням (слоям).
начиная от корня.
BFS - Breadth First Search
Используется очередь, в которой хранятся вершины,
требующие просмотра.
За одну итерацию алгоритма:
 - если очередь не пуста, извлекается вершина из
очереди.
 - посещается (обрабатывается) извлеченная вершина,
 - в очередь помещаются все дочерние.
Порядок обработки узлов дерева на рис. 209-07:
Е, D, Н, В, F, А, С, G.

// Обход в ширину.
void TraverseBFS( CBinaryNode* root)
{
queue<CBinaryNode*> 9;
q.put( root);
while( !q. empty()) {
CBinaryNode* node = q.pop();
visit( node );
if( node->Left != NULL)
q.push( node->Left);
if( node->Right != NULL)
q.push( node->Right );
}
};





Двоичное дерево поиска (binary search tree, BST) — это двоичное дерево, для которого выполняются следующие условия: 
  Оба поддерева — левое и правое, являются двоичными деревьями поиска; с каждым узлом дерева связан ключ; 
  У всех узлов левого поддерева произвольного узла «A» значения ключей меньше значения ключа самого узла «A». 
  У всех узлов правого поддерева того же узла «A» значения ключей не меньше значения ключа узла «A». 

При реализации двоичное дерево поиска можно определить так: 
  Двоичное дерево состоит из узлов — записей вида (data, left, right, parent, root).
  Данные (data) обычно обладают ключом (key), на котором определен operator<.
  Для любого узла «А» выполняются свойства дерева поиска: key[left[А]] < key[А] ≤ key[right[А]].

209-08

Операции с двоичным деревом поиска:
1. Поиск по ключу.
2. Поиск минимального, максимального ключей.
3. Вставка.
4. Удаление.
5. Обход дерева в порядке возрастания ключей.

Поиск по ключу.
Дано: указатель на корень дерева X и ключ К.
Задача: проверить, есть ли узел с ключом Кв дереве, и если да, то
вернуть указатель на этот узел.
Алгоритм: Если дерево пусто, сообщить, что узел не найден, и
остановиться.
Иначе сравнить К со значением ключа корневого узла Х.
. Если K == X, выдать ссылку на этот узел и остановиться.
• Если К > Х., рекурсивно искать ключ К в правом поддереве Х.
• Если K < Х, рекурсивно искать ключ К в левом поддереве X
Время работы: 0(h), где h - глубина дерева.

// Поиск. Возвращает узел с заданным ключом. NULL, если
узла
// с таким ключом нет.
CNode* Find( Cnode* node, int value )
{
if( node == NULL)
return NULL;
if( node->Data == value )
return node;
if( node->Data > value )
return Find( node-> Left, value );
else
return Find( node->Right, value );
};

Поиск минимального ключа.
Дано: указатель на корень непустого дерева Х.
Задача: найти узел с минимальным значением ключа.
Алгоритм: Переходить в левый дочерний узел, пока
такой существует.
Время работы: О(h), где һ– глубина дерева.

// Поиск узла с минимальным ключом.
CNode* FindMinimum( CNode* node )
{
assert( node != NULL );
while( node->Left != NULL )
node = node ->Left;
return node;
};

// Поиск. Возвращает узел с заданным ключом. NULL, если
узла
// с таким ключом нет.
CNode* Find( CNode* node, int value )
{
if( node == NULL )
return NULL;
if( node->Data == value )
return node;
if( node->Data > value )
return Find( node->Left, value );
else
return Find( node->Right, value );
};

Добавление узла.
Дано: указатель на корень дерева Хиключ К.
Задача: вставить узел с ключом Кв дерево (возможно появление
дубликатов).
Алгоритм: Если дерево пусто, заменить его на дерево с одним
корневым узлом и остановиться,
Иначе сравнить К с ключом корневого узла Х.
• Если К< Х. рекурсивно добавить Кв левое поддерево Х.
Иначе рекурсивно добавить Кв правое поддерево Х.
Время работы: O(h), где һ- глубина дерева.

// Вставка. Не указываем раrеnt.
void Insert( Cnode*& node, int value )
{
if( node == NULL) {
node = new Code( value );
return;
}
if( node->Data > value )
Insert( node->Left, value );
else
Insert( node->Right, value );
};


Удаление узла.
Дано: указатель на корень дерева Хи ключ К.
Задача: удалить из дерева узел с ключом K (если такой есть).
Алгоритм: Если дерево пусто, остановиться.
Иначе сравнить Kc ключом корневого узла Х.
Если K«Х. рекурсивно удалить к из левого поддерева т.
• Если К»X. рекурсивно удалить Киз левого поддерева Т.
Если Kau X, то необходимо рассмотреть три случая:
1 Обоих, дочерних нет. Удаляем узел X, обнуляем ссылку.
2. Одного дочернего нет. Переносим дочерний узел в Х.
удаляем узел.
3. Оба дочерних узла есть.


Удаление узла. Случай 3 Есть оба дочерних узла. Заменяем ключ
удаляемого узла на ключ минимального узла из правого поддерева, удаляя
последний.
Пусть удаляемый узел - X, a Ү - его правый дочерний.
• Если у узла Y отсутствует левое поддерево, то копируем из УвХ ключ и
указатель на правый узел. Удаляем Y.
• Иначе найдем минимальный узел 2 в поддереве Y. Копируем ключ из..
удаляем 2. При удалении 2 копируем указатель на левый дочерний узел
родителя Z на возможный правый дочерний узел
Время работы удаления: O(h), где һ- глубина дерева.

209-09

Удаление. Возвращает false, если нет узла с заданным ключом.
bool Delete( CNode*& node, int value )
{
if( node -- )
return false;
if( node->Data - value) { // Haunu, yaannem
DeleteNode( node );
return true;
)
return Delete( node->Data > value ?
node->Left : node->Right, value);
};

// Удаление узла,
void DeleteNode( CNode & node)
{
if( node->Left se) (// Если нет левого поддерева.
CNode* right = node ->Right; // Подставляем правое, может быть е.
delete node;
node = right;
} else if (node -> Right == 0) { // Если нет правого поддерева.
CNode* left = пode -> Left; / Подставляем левое.
delete node;
node = left;
} else { // Есть оба по дерева.
//Ищем минимальный элемент в правом поддереве и его родителя.
CNode* minParent = node;
CNode* min = node->Right;
while( min->Left != 0) {
minParent = min;
min = min->Left;
}
// переносим значение.
node->Data = min->Data;
// Удаляем min, подставляя на его место min-> Right.
(minParent->Left == min ? minParent->Left : minParent->Right)
= min->Right;
delete min;
}
}

// Удаление. Возвращает false, если нет узла с заданным ключом.
bool Delete( CNode*& node, int value )
{
if( node == 0)
    return false;
if( node -> Data == value ) { // нашли, удаляем
DeleteNode( node );
return true;
}
return Delete( node->Data > value ?
node->Left : node->Right, value );
};

  Основным преимуществом двоичного дерева поиска перед другими структурами данных является высокая эффективность реализации основанных на нём алгоритмов поиска и сортировки.

 Путем из узла n1 в узел nк называется последовательность узлов n1,n2... nк.
 Длинной пути называется число, на единицу меньше числа узлов, составляющих этот путь.
 Если существует путь из узла a в узел b, то в этом случае узел a называется предком узла b, а узел b – потомком узла а.
 Глубина узла определяется как длинна пути от корня до этого узла.
 Высота дерева совпадает с высотой его корня.

Реализация на С#

class BinaryTreeNode<TNode> : IComparable<TNode> where TNode : IComparable<TNode>
{
public BinaryTreeNode<TNode> Left { get; set; }
public BinaryTreeNode<TNode> Right { get; set; }
public int CompareTo(TNode other)
{
return Value.CompareTo(other);
}
}

Если дерево не содержит узлов (пустое), то новое значение становится корнем нового дерева. Если
дерево не пустое, то мы сравниваем значение нового узла со значением корня дерева, если новое
значение больше, то алгоритм повторяется для правого потомка, если меньше то для левого.
public class BinaryTree<T> : IEnumerable<T>  where T : IComparable<T>
{
public void Add(T value)
{
…………
}
}

Поиск узла в дереве начинается с его корня (метод FindWithParent) и предполагает следующие
шаги:
1. Если значения текущего узла null - закончить поиск и вернуть null.
2. Если значения текущего узла равно искомому, результатом поиска будет текущие значение
узла.
3. Если искомое значение меньше чем текущие, нужно перейти к левому потомку и повторить
алгоритм с первого пункта.
4. Если значение больше или равно текущему, нужно перейти к правому потомку и повторить
алгоритм с первого пункта.
Метод Contains() основывается на методе поиска и определяет принадлежит ли указанный элемент
дереву или нет, если да то он возвращает true, в противном случае false.


При удалении узла из дерева нужно учитывать три возможных варианта:
• Первый вариант: удаляемый узел не имеет правого потомка.
• Второй вариант: удаляемый узел имеет правого потомка, у которого нет левого потомка.
• Третий вариант: удаляемый узел имеет правого потомка, у которого есть левый потомок.

Первый вариант
Если удаляемый узел(5) не имеет правого потомка, то достаточно переместить на его место левого
потомка(2).
209-01.png

Второй вариант
Если удаляемый узел(5) имеет правого потомка(6), у которого в свою очередь, тоже есть правый
потомок(7), то достаточно переместить их с соблюдением иерархии.
209-02.png

Третий вариант
Если удаляемый узел (5) имеет правого потомка (7), у которого в свою очередь есть левый
потомок(6), то крайний левый потомок узла (7) должен быть перемещен на место удаляемого узла.
209-03.png

.
Алгоритм обхода двоичного дерева предусматривает обход всех вершин дерева только один раз.
Существуют три вида таких обходов:
Прямой порядок (англ. preorder), посещение узлов родителей до посещения узлов потомков:
1) Зайти в корень.
2) Зайти в левое поддерево.
3) Зайти в правое поддерево.
Обратный порядок (англ. postorder), посещение узлов потомков до посещения узлов их родителей:
1) Зайти в левое поддерево.
2) Зайти в правое поддерево.
3) Зайти в корень.
Симметричный порядок(англ. inorder):
1) Зайти в левое поддерево.
2) Зайти в корень.
3) Зайти в правое поддерево.

Прямой порядок 
Порядок следования при прямом обходе дерева: 4, 2, 1, 3, 5, 7, 6, 8
209-04

Обратный порядок
Порядок следования при обратном обходе дерева: 1, 3, 2, 6, 8, 7, 5, 4
209-05

Симметричный порядок
Порядок следования при обратном обходе дерева: 1, 2, 3, 4, 5, 6, 7, 8
209-06



Балансировка

Все перечисленные операции с деревом поиска
выполняются за O(h), где h - глубина дерева.
Глубина дерева может достигать n.
Последовательное добавление возрастающих
элементов вырождает дерево в цепочку узлов с одним дочерним элементом.
Необходима балансировка.

.
Самобалансирующиеся деревья.
Случайная балансировка:
 - Декартовы деревья.
Гарантированная балансировка:
 - АВЛ-деревья,
 - Красно-черные деревья.
«Амортизированная» балансировка:
 - Сплэй-деревья.

Декартово дерево — это структура данных,
объединяющая в себе двоичное дерево поиска и
двоичную кучу.
Определение 1. Декартово дерево — двоичное дерево, в
узлах которого хранится пары (x, y), где х - это ключ, а у - это
приоритет. Все х и все у являются различными. Если некоторый
элемент дерева содержит (хо, Уо), то у всех элементов в левом
поддереве х < xo,  у всех элементов в правом поддереве х > хо, а
также и в левом, ив правом поддереве у < yo
Таким образом, декартово дерево является двоичным деревом
поиска по х и кучей по у.

Другие названия:
treap (tree+heap).
- дуча (дерево + куча).
- дерамида (дерево + пирамида).
- курево (куча + дерево).
Изобретатели — Сидель и Арагон (1989)

209-10

Свойство: средняя глубина дерева = O(log n)

Основные операции:
• Разрезание - Split,
• Слияние – Мегде.
На основе этих двух операций реализуются операции:
• Вставка
Удаление.


Разрезание — Split
Операция «разрезать» позволяет разрезать декартово дерево, по
ключу к и получить два других декартовых дерева:Т1 и Т2, причем
в т1 находятся все ключи дерева Т, не большие К, а в т2 -
большие К.

209-11

// Разрезание декартового дерева по ключу.
void Split( CTreapNode* currentNode, int key, CTreapNode*& left,
CTreapNode*& right)
{
if( currentNode == 0 ) {
left = 0;
right = 0;
} else if( currentNode->key <= key ) {
Split(currentNode->Right, key, currentNode->Right, right );
left = currentNode;
} else {
Split( currentNode->Left, key, left, currentNode->Left );
right = currentNode;
}
}

Слияние — Merge
Операция «слить» позволяет слить два декартовых
дерева в одно. Причем, все ключи в первом (левом)
дереве должны быть меньше, чем ключи во втором
(правом). В результате получается дерево, в котором
есть все ключи из первого и второго деревьев.

209-12


// Слияние двух декартовых деревьев.
CTreapNode* Merge( CTreapNode* left, CTreapNode* right )
{
if( left == 0 || right == 0){
return left == 0 ? right : left;
}
if( left->Priority > right->Priority ) {
left->Right = Merge( left->Right, right);
return left;
}
right->Left = Merge( left, right->Left);
return right;
}

Вставка
Добавляется элемент (x, y), где х - ключ, а у - приоритет.
Элемент (x, y) - это декартово дерево из одного элемента. Для
того чтобы его добавить в наше декартово дерево Т.
очевидно, нужно их слить. Но Т может содержать ключи как
меньше, так и больше ключа х, поэтому сначала нужно
разрезать Т по ключу х.
Реализация #l,
1.
Разобьём наше дерево по ключу х, который мы хотим
добавить, на поддеревья Т1 и Т2.
2 Сливаем первое дерево Т, с новым элементом.
3. Сливаем получившиеся дерево со вторым Т2.

Вставка
Реализация No2.
1 Сначала спускаемся по дереву (как в обычном бинарном
дереве поиска по х), но останавливаемся на первом элементе.
в котором значение приоритета оказалось меньше у.
2. Теперь разрезаем поддерево найденного элемента на T1, и Т2.
3  Полученные Т1, и Т2 записываем в качестве левого и правого
детей добавляемого элемента.
4. Полученное дерево ставим на место элемента, найденного в
первом пункте.
В первой реализации два раза используется Мегде, а во второй
реализации слияние вообще не используется.

Удаление.
Удаляется элемент с ключом х.
Реализация 1.
І. Разобьём дерево по ключу х, который мы хотим
удалить, на T1 и T2.
2. Теперь отделяем от первого дерева Т1 элемент x.
разбивая по ключу х - £.
3. Сливаем измененное первое дерево Т1 со вторым Т2

Удаление.
Реализация №2.
І. Спускаемся по дереву (как в обычном двоичном
дереве поиска по х), ища удаляемый элемент.
2. Найдя элемент, вызываем слияние его левого и
правого детей.
3. Результат процедуры ставим на место удаляемого
элемента.
В первой реализации два раза используется Split, а во
второй реализации разрезание вообще не используется.


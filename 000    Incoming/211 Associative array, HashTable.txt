АТД Ассоциативный массив

Определение 4. Ассоциативный массив — абстрактный
тип данных, позволяющий хранить пары вида «(ключ,
значение)» и поддерживающий операции добавления
пары, а также поиска и удаления пары по ключу:
• INSERT(ключ, значение).
• FIND(ключ). Возвращает значение, если есть пара с
заданным ключом.
• REMOVE(ключ).
Предполагается, что ассоциативный массив не может
хранить две пары с одинаковыми ключами.


Расширение ассоциативного массива.
Обязательные три операции часто дополняются
другими. Наиболее популярные расширения включают
следующие операции:
• CLEAR - удалить все записи.
• ЕАСH — «пробежаться» по всем хранимым парам
• MIN — найти пару с минимальным значением ключа
• МАX - найти пару с максимальным значением ключа
В последних двух случаях необходимо, чтобы на ключах
была определена операция сравнения.

Реализации ассоциативного массива.
- Массив пар, упорядоченных по ключү. 
Поиск - бинарный.
Время поиска O(log n). Время вставки и удаления O(n).

- сбалансированное дерево поиска.
Время работы операций поиска, вставки и удаления - O(log n).
std:mар реализован на основе красно-черного дерева.

- Хеш-таблицы.
Все операции в среднем - O(1), в худшем - O(n).

Хеш-таблица —  это  динамическая структура  данных,  реализующая интерфейс ассоциативного  массива,  а  именно,  она  позволяет  хранить  пары  (ключ, значение)  и  выполнять  три  операции:  операцию  добавления  новой  пары,  операцию 
поиска и операцию удаления пары по ключу.
211-01

Задача. Хранить ключи в контейнере:
• быстро добавлять,
• быстро удалять,
• быстро проверять наличие.
Решение 1.
Упорядоченный массив:
• длительное добавление – O(n),
• длительное удаление – O(n),
• быстрый поиск – O(log n).

Задача. Хранить ключи в контейнере:
• быстро добавлять,
• быстро удалять,
• быстро проверять наличие.
Частное решение 2.
Пусть ключи – неотрицательные целые числа в диапазоне [0, . . , n − 1].
Будем хранить A – массив bool.
̀A[i] = true <=>  i содержится:
• мгновенное добавление – O(1),
• мгновенное удаление – O(1),
• мгновенный поиск – O(1).

Хеширование – преобразование ключей к числам.
Хеш-таблица – массив ключей с особой логикой, состоящей из:
1. Вычисления хеш-функции, которая преобразует ключ поиска в индекс.
2. Разрешения конфликтов, т.к. два и более различных ключа могут преобразовываться в один и тот же индекс массива. 
Отношение порядка над ключами не требуется.

Заполнение массива значениями происходит случайным образом в порядке определенном хеш-функцией, которая в качестве аргумента приминает значение ключа. Функция принимая ключ «someStringKey», а возврещает целочисленный хеш-код. Индекс по которому
этот хеш-код будет размещен в массиве, есть результатом деления его с остатком на размерность массива.
int index = hash(“someStringKey”) % Capacity.

Пусть хеш-таблица имеет размер M, количество элементов в хеш-таблице – N.
Число хранимых элементов, делённое на размер массива (число возможных значений хеш-
функции), называется коэффициентом заполнения хеш-таблицы (load factor). 
Обозначим его a = N / M.
Этот коэффициент является важным параметром, от которого зависит среднее время выполнения операций.

Существуют два основных варианта хеш-таблиц: с цепочками и открытой адресацией. 
Хеш-таблица содержит некоторый массив, элементами которого есть пары (хеш-таблица с открытой адресацией), или списки пар (хеш-таблица с цепочками). Сложность быстрого доступа к элементам хеш-таблицы соотвественно О(1) и О(n). 
Массив содержит два важных для быстрого доступа свойства - это размерность и степень заполнения массива.

Выполнение операции в хеш-таблице начинается с вычисления хеш-функции от ключа. 
Получающееся хеш-значение играет роль индекса в массиве Н. 
Затем выполняется операция (добавление, удаление или поиск) объекта, по найденому индексу.

Ситуация, когда для различных ключей получается одно и то же хеш-значение, называется коллизией. 
Такие события не так уж и редки — например, при вставке в хеш-таблицу размером 365 ячеек всего лишь для 23-х элементов вероятность коллизии уже превысит 50 % (если каждый элемент может равновероятно попасть в любую ячейку). 
Поэтому механизм разрешения коллизий — важная составляющая любой хеш-таблицы. 

Варианты реализации

public int LengthHashCode(string input) 
{     
return input.Length; 
}
Хеш метод для типа string ( плохой пример):
Решение не универсальное, поскольку возвращает только длину строки. Не позволяет получить
уникальный код для каждой строки одинаковой длинны.

private int AdditiveHash(string input)
{     
int currentHashValue = 0;  
foreach (char c in input)     
{         
unchecked 
{             
currentHashValue += (int)c;         
}     
}  
return currentHashValue; 
}


private static int Djb2(string input) 
{     
int hash = 5381;  
foreach (int c in input.ToCharArray())     
{         
unchecked
{             
hash = ((hash << 5) + hash) + c;         
}     
}  
return hash; 
}

В некоторых специальных случаях удаётся избежать коллизий вообще. Например, если все ключи элементов известны заранее (или очень редко меняются), то для них можно найти некоторую совершенную хеш-функцию, которая распределит их по ячейкам хеш-таблицы без коллизий. Хеш-таблицы, использующие подобные хеш-функции, не нуждаются в механизме разрешения коллизий, и называются хеш-таблицами с прямой адресацией. (see GNU gperf)

Даже самы хороший хеш алгоритм, который формирует ключи для хеш таблицы, не избавляет от возможности появления коллизий.
Чтобы избежать непредвиденной перезаписи ключей в массиве, используют специальный метод, который перед добавлением нового значения в массив, ищет для него пустую ячейку.

**Метод цепочек**

Каждая ячейка массива является указателем насвязный список (цепочку).
Коллизии приводят к тому, что появляются цепочки длиной более одного элемента.
211-02


Добавление ключа.
1. Вычисляем значение хеш-функции добавляемого ключа – h.
2. Находим A[h] – указатель на список ключей.
3. Вставляем в начало списка (в конец списка дольше). 
Если запрещено дублировать ключи, то придется просмотреть весь список.
Время работы:
В лучшем случае – O(1).
В худшем случае
– если не требуется проверять наличие дубля, то O(1),
– иначе – O(N).

Удаление ключа.
1. Вычисляем значение хеш-функции удаляемого ключа – h.
2. Находим A[h] – указатель на список ключей.
3. Ищем в списке удаляемый ключ и удаляем его.
Время работы:
В лучшем случае – O(1).
В худшем случае – O(N).

Поиск ключа.
1. Вычисляем значение хеш-функции ключа – h.
2. Находим A[h] – указатель на список ключей.
3. Ищем его в списке.
Время работы:
В лучшем случае – O(1).
В худшем случае – O(N).

Среднее время работы.

Среднее время работы операций поиска, вставки (с проверкой на дубликаты) и удаления в хеш-таблице, 
реализованной методом цепочек – O(1 + a), где a – коэффициент заполнения таблицы.
(Среднее время работы = математическое ожидание времени работы в зависимости от исходного ключа.)

// Хеш-функция.
template<class T>
int Hash( T& data );
// Элемент цепочки в хеш-таблице.
template<class T>
struct CHashTableNode {
T Data;
CHashTableNode<T>* Next;
};
// Хеш-таблица.
template<class T>
class CHashTable {
public:
CHashTable( int initialSize );
bool Has( T& key ) const;
void Add( T& key );
bool Delete( T& key );
private:
vector<CHashTableNode<T>*> table;
};

Открытая адресация.

Все элементы хранятся непосредственно в массиве.
Каждая запись в массиве содержит либо элемент, либо
NIL.
При поиске элемента систематически проверяем ячейки
до тех пор, пока не найдем искомый элемент или не
убедимся в его отсутствии.
211-03

Вставка ключа.
1. Вычисляем значение хеш-функции ключа – h.
2. Систематически проверяем ячейки, начиная от
A[h], до тех пор, пока не находим пустую
ячейку.
3. Помещаем вставляемый ключ в найденную
ячейку.
В п.2 поиск пустой ячейки выполняется в некоторой
последовательности. Такая последовательность
называется «последовательностью проб».


Последовательность проб зависит от вставляемого
в таблицу ключа. Для определения исследуемых
ячеек расширим хеш-функцию, включив в нее
номер пробы
(от 0).
ℎ ∶ U x {0,1,...,M-1} -> {0,1,...,M-1}
Важно, чтобы для каждого ключа k последовательность проб 
<h(k,0), h(k,1), ..., h(k, M-1)>
представляла собой перестановку множества <0, 1, ..., M-1>, чтобы могли быть простмотсрены все ячейки таблицы.

// Вставка ключа в хеш-таблицу (без учета удаленных 
элементов).
void CHashTable::Insert( T& k )
{
for( int i = 0; i < tableSize; ++i ) {
int j = h( k, i );
if( IsNil( table[j] ) ) {
table[j] = k;
return;
}
}
throw CHashTableException( “Overflow” );
}

Поиск ключа.
Исследуется та же последовательность, что и в
алгоритме вставки ключа.
Если при поиске встречается пустая ячейка, поиск
завершается неуспешно, поскольку искомый ключ
должен был бы быть вставлен в эту ячейку в
последовательности проб, и никак не позже нее.

Удаление ключа.
Алгоритм удаления достаточен сложен.
Нельзя при удалении ключа из ячейки i просто пометить
ее значением NIL. Иначе в последовательности проб для
некоторого ключа (или некоторых) возникнет пустая
ячейка, что приведет к неправильной работе алгоритма
поиска.
Решение. Помечать удаляемые ячейки спец. значением
«Deleted».
Нужно изменить методы поиска и вставки.
В методе вставки проверять «Deleted», вставлять на его
место.
В методе поиска продолжать поиск при обнаружении
«Deleted».

Вычисление последовательности проб.
Желательно, чтобы для различных ключей k 
последовательность проб <h(k,0), h(k,1), ..., h(k, M-1)>
давала большое количество последовательностей-перестановок множества {0,1,...,M-1}

Обычно используются три метода построения h(k,i)

1. Линейное пробирование
2. Квадратичное пробирование
3. Двойное Хеширование

**Линейное пробирование.**
h(k,i) = (ℎ′(k) + i) mod M.
Основная проблема – кластеризация.
Последовательность подряд идущих занятых элементов таблицы быстро увеличивается, образуя кластер.
Попадание в элемент кластера при добавлении гарантирует «одинаковую прогулку» для различных
ключей и проб. Новый элемент будет добавлен в конец
кластера, увеличивая его.
Если ℎ (k_1, i) = ℎ (k_2, j), то ℎ (k_1, i + r) = ℎ (k2, j + r) для всех r.

**Квадратичное пробирование.**
h(k,i) = (ℎ′(k) + c_1 ⋅ i + c_2 ⋅ i^2) mod M.

требуется, чтобы последовательность проб содержала все индексы 0,1,...,M-1.
Требуется подбирать c_1 и c_2.

При c_1 = c_2 = 1/2 и M = 2^p проба вычисляется реккурентно (и дает нужную перестановку):

h(k, i + 1) = (ℎ(k,i) + i + 1) mod M.

Возникает вторичная кластеризация. Проявляется на
ключах с одинаковым хеш - значением h'().
Если һ(k1,0) = һ(k2,0), то һ(k1, i) = һ(k2, i) для всех і.
Соответствует цепочкам в методе цепочек. Разница
лишь в том, что в методе открытой адресации эти
цепочки могут еще пересекаться.

Двойное хеширование,
h(k, i) = (h1 (k) + ih2 (k)) mod м.
Требуется, чтобы последовательность проб содержала
все индексы 0, .. , M-1. Для этого все значения h2 (k)
должны быть взаимно простыми с М.
M может быть степенью двойки, а h2(k) всегда
возвращать нечетные числа.
• М простое, а h2(k) меньше М.

Общее количество последовательностей проб = O (M^2).

Теорема. 
Математическое ожидание количества проб при неуспешном поиске в хеш-таблице с открытой
адресацией и коэффициентом заполнения а = n/m <1 в
предположении равномерного хeширования не
превышает 1/(1-а)

Время работы методов поиска, добавления и удаления:
В лучшем случае — O(1).
В худшем случае — O(N).
В среднем O (1/(1-а)).

Плюсы.
+ Основное преимущество метода открытой адресации – не тратится память на хранение указателей списка.
+ Нет элементов, хранящихся вне таблицы.
Минусы.
– Хеш-таблица может оказаться заполненной. 
Коэффициент заполнения *a* не может быть больше 1.
– При приближении коэффициента заполнения *a* к 1 
среднее время работы поиска, добавления и удаления
стремится к *N*.
– Сложное удаление.


Динамическая хеш-таблица.

Изначально может быть неизвестно количество
хранимых ключей. Коэффициент заполнения а
может приближаться к 1, а в реализации методом
цепочек может быть больше 1.
Среднее время работы для метода цепочек:
0(1 + a),
для открытой адресации 0(1/(1 — а)).
Требуется динамически увеличивать размер
таблицы. Аналогично динамическому массиву.
Процесс увеличения размера хеш-таблицы
называется «перехешированием».

Перехеширование.
1. Создать новую пустую таблицу. Размер новой
таблицы M  может быть равен 2 ∙ M, где M –
размер старой таблицы. Если размер таблицы
должен быть простым, то следует использовать
простое число близкое к 2 ∙ M.
2. Проитерировать старую таблицу. Каждый ключ
старой таблицы перенести в новую. Для
добавления в новую таблицу надо использовать
другую хеш-функцию, возвращающую значения
от 0 до M  − 1.

Когда выполнять перехеширование?
Для разных хеш-таблиц следует использовать разные
стратегии.
Для хеш-таблиц, реализованных методом цепочек:
Например, когда коэффициент заполнения 㘶 достиг 1.
Для хеш-таблиц, реализованных методом открытой
адресации:
Например, когда a достиг значения ⅔ или ¾.


Время работы.
211-04


**Хеш-функция** ― преобразование по детерминированному алгоритму входного массива данных произвольной длины (один ключ) в выходную битовую строку фиксированной длины (значение).
Результат вычисления хеш-фукнции называют «хешем».
**Коллизией** хеш-функции H называется два различных входных блока данных X и Y таких, что H(x) = H(y)

Количество возможных значений хеш-функции не больше M и для любого ключа k:
0 ≤ ℎ (k) < M
Важно! Хорошая хеш-функция должна:
1. Быстро вычисляться.
2. Минимизировать количество коллизий.
HASH = рубить, перемешивать.

Пример плохой хеш-функции.
h(k) = [последние [три] цифры k] = k % 1000.
Такая хеш-функция порождает много коллизий, если множество ключей – цены.
Частые значения: 000, 500.00, 999.99, 998.50, 990.00, 900.00.


**Метод деления**
h(k) = k mod M.
M определяет размер диапазона значений: [0, .. , M–1].
Как выбрать M?
• Если M = 2^K, то значение хеш-функции не зависит от старших байтов.
• Если M = 2^8 − 1, то значение хеш-функции не зависит от перестановки байт.
Обычно в качестве M выбирают простое число, далекое от степеней двойки.


**Метод деления многочленов**
Пусть
K(x) = k_0 + k_1⋅x + ... + k_n⋅x^n,
P(x) = p_0 + p_1⋅x + ... + p_m⋅x^m.
Деление многочленов с остатком:
K(x) = ̀A(x) ⋅ P(x) + R(x) ,
̀A(x) – частное, R(x) – остаток, deg R < deg P = m.
Все коэффициенты в поле. Например, в поле Z_p, p - простое число
Делить удобно в столбик

Каждый ключ К определяется числами (k_0, k_1, ..., k_(n-1)).
Пусть К (x) = k_0 + k_1⋅x + ... + k_(n-1) ⋅ x^(n-1).
Пусть задан полином Р(х) = p_0 +p1⋅x+ ... + p_m ⋅ х^m.
Многочлен Р(х) называют порождающим многочленом.

Определим хеш-функцию как остаток от деления:
H_P(К)(x) = K(x) mod P(x) =
= h_0 +h1⋅x + ... +h_(m-1) ⋅ х^(m-1) = (ho, h1, ...,h_(m -1)).
Все коэффициенты в поле Z_р, где р — простое.
В алгоритмах CRC используется р= 2 и немного другая формула
H_P(K)(x) = K(x) ⋅ х^m mod P(x)


Метод умножения

h(k) = [M ⋅ {k ⋅ A}],
где {} – дробная часть,
где [] – целая часть,
А — действительное число, 0< A <1,
M определяет диапазон значений: (0, .. , M—1].
Кнут предложил в качестве А использовать число, обратное к золотому сечению:

А = Ф^(-1) = (sqrt(5) - 1) / 2 = 0.6180339887...

Такой выбор А дает хорошие результаты хеширования.

Хеш-функцию h(k) = [M ⋅ {k ⋅ A}] вычисляют без использования операций с числами с плавающими точками.
Пусть М — степень двойки. М = 2^p, p <= 32.
Вместо действительного числа А берут близкое к нему A = s / 2^32 = 2654435769 / 2^32,
То есть, s = 2654435769.

Тогда h(k) = [2^p ⋅ {k ⋅ s/2^32}] = [2^p ⋅ { (r1⋅2^32 + r0)/2^32 }] =
= [2^p ⋅ r0/2^32] = [r0/(2^(32-p))] = [ (r01⋅2^(32-p) + r00) / (2^(32-p)) ] = r01
= Старшие р бит r0
Итого, h(k) = (k ⋅ s mod 2^32) >> (32 – р).

**Хэш-функция строки**

Строка s = s_0, s_1, ..., s_(n-1).

* h_1(s) = (s_0 + s_1 ⋅ a + s_2 ⋅ a^2 + ... + s_(n-1) ⋅ a^(n-1)) mod M
* h_2(s) = (s_0 ⋅ a^(n-1) + s_1 ⋅ a^(n-2) + ... + s_(n-1)⋅ a^0 ) mod M

Если a и M не являются взаимно простыми, то {s ⋅ a mod M, 0<= s <M} != {0, ..., M-1}.
Если a и M взаимно простые, то {s ⋅ a mod M, 0<= s <M} = {0, ..., M-1}.

h_2(s) вычисляется эффектевнее, если использовать метод Горнера:

h_2(s) = (((s_0 ⋅ a + s_1) ⋅ a + s_2) ⋅ a + ... + s_(n-2)) ⋅ a + s_(n-1).

h_1(s) можно вычислять аналогично, но начиная с конца строки.

Но в Си-строках известен только указатель на начало строки, а размер строки не известен.

Поэтому удобнее вычислять h_2(s).

// Хеш-функция строки.
int Hash( const char* str, int m )
{
int hash = 0;
for( ; *str != 0; ++str )
hash = ( hash * a + *str ) % m;
return hash;
}


**Другие хеш-функции**

Функции вычисления контрольной суммы также 
являются хеш-функциями.
CRC ― циклически избыточный код, Cyclic redundancy 
check. Использует метод деления многочленов, но не 
просто остаток от деления многочленов, а:
H_P(K)(x) = K(x) ⋅ х^m mod P(x), коэффициенты в поле Z_2.
Для разных версий используются многочлены разных 
степеней, с разными коэффициентами.

CRC стандарт Многочлен
CRC-1:               x + 1
CRC-5-USB:           x^5 + x^2 + 1
CRC-8:               x^8 + x^7 + x^6 + x^4 + x^2 + 1
CRC-16(-IBM):        x^16 + x^15 + x^2 + 1
CRC-32-IEEE 802.3:   x^32 + x^26 + x^23 + x^22 + x^16 + x^12 + x^11 + x^10
                         + x^8 + x^7 + x^5 + x^4 + x^2 + x + 1
CRC-64-ISO:          x^64 + x^4 + x^3 + x^ + 1

MD1, MD2, MD3, MD4, MD5, MD6 ― известные алгоритмы 
вычисления контрольных сумм.
Message Digest. Один из самых популярных – MD5 – 128-битный 
алгоритм хеширования. Разработан Рональдом Л. Ривестом в 
1991г. Использует битовые операции с блоками длины 128.
Важное преимущество MD – лавинный эффект. Замена одного 
символа приводит к полному изменению хеша:
MD5("md5") = 1BC29B36F623BA82AAF6724FD3B16718.
MD5("md4") = C93D3BF7A7C4AFE94B64E30C2CE39F4F

Криптографические хеш-функции.
SHA-1, SHA-2 ― 160, 256/512-битные хеши.
SHA = Secure Hash Code.
Криптографические = нет способа нахождения коллизий.



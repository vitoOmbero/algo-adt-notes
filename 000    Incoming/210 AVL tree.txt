 АВЛ-дерево — сбалансированное по высоте двоичное дерево поиска: для каждой его вершины высота её двух поддеревьев различается не более чем на 1.

Расход памяти и время работы
210-07


Правила построения двоичных деревьев поиска:
• каждый узел может иметь не более двух потомков (левый и правый);
• значения которые меньше текущего размещаются в левом поддереве;
• значения которые больше или равные текущему размещаются в правом поддереве;
Дополнительное условие для АВЛ-дерева:
• для любого узла дерева, высота его правого поддерева никогда не превышает высоты его левого поддерева более чем на единицу.
*Этого свойства достаточно, чтобы высота дерева имела логарифмическую зависимость от
числа его узлов.

Высота дерева логарифмически зависит от числа его узлов h = O(log n).
Высота h АВЛ-дерева с n ключами лежит в диапазоне от log2(n + 1) до 1.44 log2(n + 2) − 0.328. 
А так как основные операции над двоичными деревьями поиска (поиск, вставка и удаление узлов) линейно зависят от его высоты, то получаем гарантированную логарифмическую зависимость времени работы этих алгоритмов от числа ключей, хранимых в дереве.

Деревья  поиска  обеспечивают  сбалансированность  только  в  вероятностном  смысле: 
вероятность  получения  сильно  несбалансированного  дерева  при  больших  n  хотя  и 
является пренебрежимо малой, но остается не равной нулю. 

Не сбалансированное дерево
Минимальная высота левого и правого поддерева не может отличатся больше чем на единицу и это правило характерно для всех узлов дерева. Если рассмотреть корень узла, то его левое поддерево имеет высоту два, а правое – ноль, поэтому дерево не сбалансировано.
210-01.png

Частично сбалансированное дерево
Дерево называется полностью сбалансированным, если каждый узел дерева сбалансированный.
Узел «7» не сбалансированный, поскольку высота правого поддерева два, а левого – ноль.
210-02.png

Относительно  АВЛ-дерева  балансировкой  вершины  называется  операция,  которая  в 
случае разницы высот левого и правого поддеревьев, изменяет связи предок-потомок в 
поддереве данной вершины так, что разница становится <= 1, иначе ничего не меняет. 
Указанный результат получается вращениями поддерева данной вершины. 

Алгоритм балансировки
АВЛ-дерево
Для определения сбалансировано дерево по высоте или нет, требуется проверить высоту правого и левого потомка каждого узла. При необходимости балансировки, узлы подлежат удалению, добавлению или вращению.
АВЛ-деревья используют базовые алгоритмы вращения узла:
• правое вращение,
• левое вращение,
• два смешанных алгоритма, которые базируются на первых двух.

Существуют  четыре  типа  вращения:  вращение  влево,  вращение  вправо,  вращение влево, а потом в право и в обратной последовательности.

Вращение узла вправо

Корень и его левый поток меняются ролями таким образом, что левый поток становится новым корнем, а его бывшее правое поддерево становится левым поддеревом старого корня; при этом, старый корень становится правым потомком нового корня.

Алгоритм вращения вправо имеет три шага:
• земенить текущий корень на его левого потомка; узел B становится корнем, а узел А занимает его место.
• переместить правого потомка нового корня на место левого потомка старого корня.
B -> C to D -> C.
• Присвоить новому корню (B) в качестве правого потомка старый корень (D).
210-03.png

Вращение узла влево

Алгоритм вращения влево осуществляется в три шага:
• земенить текущий корень на его правого потомка;
узел «С» становится корнем, а узел «А» его левым потомком.
• переместить левого потомка нового корня (B) на место правого потомка старого корня.
«С» -> «B» to «A» -> «B».
• Присвоить новому корню (С) в качестве правого узла значение старого корня (D).
210-04

Вращение вправо и влево

Данная ситуация отличается от предыдущих, поскольку правый потомок корня имеет левого
потомка, но не имеет правого.
210-05

Вращение влево и вправо 

Когда корень дерева имеет левого потомка, который в свою очередь имеет правого потомка, но не
имеет левого, применяют последовательной вращения влево, а затем вправо.
210-06


Малое левое вращение
• Малое левое вращение
Используется, когда:
высота(Р) = высота(L) + 2 и высота(С) < высота(R).
После операции:
высота дерева останется прежней, если высота(C) = высота(R),
высота дерева уменьшится на 1, если высота(c) < высота(R).
210-11

Малое правое вращение
210-12

Большое левое вращение
Используется, когда:
высота(R) = высота(L) +1 и высота(C) = высота(L) +2.
После операции:
высота дерева уменьшается на 1.
210-13

. Большое левое вращение
Используется, когда:
высота(R) = высота(L) +1 и высота(C) = высота(L) + 2.
После операции:
высота дерева уменьшается на 1.

210-14


Вставка элемента
І. Проходим по пути поиска, пока не убедимся, что
ключа в дереве нет.
2. Включаем новую вершину как в стандартной
операции вставки в дерево поиска.
3. "Отступаем" назад от добавленной вершины к
корню. Проверяем в каждой вершине
сбалансированность. Если разность высот
поддеревьев равна 2 - выполняем нужное
вращение.
Время работы = 0(log n).


Удаление элемента
1. Ищем вершину D, которую требуется удалить.
2. Проверяем, сколько поддеревьев в D:
Если D - лист или D имеет одно поддерево, то удаляем D.
• Если D имеет два поддерева, то ищем вершину м.
следующую по значению после D. Как в стандартном
алгоритме удаления из дерева поиска. Переносим
значение из М в D. Удаляем М.
3. "Отступаем" назад от удаленной вершины к корню.
Проверяем в каждой вершине сбалансированность. Если
разность высот поддеревьев равна 2- выполняем нужное
вращение.
Время работы = O(log n).

210-15






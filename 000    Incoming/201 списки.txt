Абстрактный тип данных = набор функций, интерфейс.
Структура данных = программная единица для обработки связанных данных, зачастую является реализацией некоторого АТД.

Линейным списком называется упорядоченная последовательность переменного числа элементов. Основными операциями с линейными списками являются:
1) получить доступ к k-му элементу;
2) включить k-й элемент;
3) исключить k-й элемент;
4) найти необходимый элемент.

Два пинципиально разных способа педставления линейного списка:
 - последовательно размещённые элементы (массив);
 - элементы, размещенные непоследовательно, сопровождаемые указателями на другие элементы (связный список);



Связный список — динамическая структура данных, состоящая
из узлов, каждый из которых содержит как собственно данные, так и одну или две ссылки («связки») на следующий и/или предыдущий узел списка.

Преимущество перед массивом:
Порядок элементов списка может не совпадать с порядком расположения элементов данных в памяти, а порядок обхода списка всегда явно задаётся его внутренними связями.

Преимущества:
 быстродействие при вставке нового элемента в список;
 неограниченное количество элементов (как например в массиве).
Недостатки:
 все элементы связных списков доступны лишь друг за другом;
 связный список не может быть сформирован только из одних элементов, 
обязательно присутствие ссылок на соседние элементы.


Односвязный список
(однонаправленный связный список)

img/201-01.png

Ссылка в каждом узле одна.
Указывает на следующий узел в списке.
Узнать адрес предыдущего элемента, опираясь на содержимое текущего узла, невозможно.

size()
get(i)
set(i, x)
add(i, x)
remove(i)
remove(x)

Двусвязный список
(Двунаправленный связный список)

img/201-02.png

Ссылки в каждом узле указывают на предыдущий и на последующий узел в списке.


Операции со списками:
 Поиск элемента,
 Вставка элемента,
 Удаление элемента,
 Объединение списков,
 …


Узел

// Элемент двусвязного списка с целочисленными
// значениями.
struct CNode {
int Data;
CNode* Next;
CNode* Prev;
CNode() : Data( 0 ), Next( 0 ), Prev( 0 ) {}
};


Поиск

// Линейный поиск элемента «a» в списке.
// Возвращает 0, если элемент не найден.
СNode* Search( CNode* head, int a )
{
CNode* current = head;
while( current != 0 ) {
if( current->Data == a )
return current;
current = current->Next;
}
return 0;
}
Время работы в худшем случае = O(n), где n – длина списка.


Вставка

// Вставка элемента «a» после текущего.
СNode* InsertAfter( CNode* node, int a )
{
assert( node != 0 );
// Создаем новый элемент.
CNode* newNode = new CNode();
newNode->Data = a;
newNode->Next = node->Next;
newNode->Prev = node;
// Обновляем Prev следующего элемента, если он есть.
if( node->Next != 0 ) {
node->Next->Prev = newNode;
}
// Обновляем Next текущего элемента.
node->Next = newNode;
return newNode;
}
Время работы = O(1).


Удаление

// Удаление элемента.
void DeleteAt( CNode* node )
{
assert( node != 0 );
// Обновляем Prev следующего элемента, если он есть.
if( node->Next != 0 ) {
node->Next->Prev = node->Prev;
}
// Обновляем Next предыдущего элемента, если он есть.
if( node->Prev != 0 ) {
node->Prev->Next = node->Next;
}
delete node;
}
Время работы = O(1).


Объединение

// Объединение односвязных списков. К списку 1 подцепляем 
список 2.
// Возвращает указатель на начало объединенного списка.
CNode* Union( CNode* head1, CNode* head2 ) {
if( head1 == 0 ) {
return head2;
}
if( head2 == 0 ) {
return head1;
}
// Идем в хвост списка 1.
CNode* tail1 = head1;
for( ; tail1->Next != 0; tail1 = tail1->Next );
// Обновляем Next хвоста.
tail1->Next = head2;
return head1;
}
Время работы = O(n), где n – длина первого списка.


Сравнение списков с массивами.

Недостатки списков:
 Нет быстрого доступа по индексу.
 Расходуется доп. память.
 Узлы могут располагаться в памяти разреженно, 
что не позволяет использовать кэширование
процессора.
Преимущества списков перед массивом:
 Быстрая вставка узла.
 Быстрое удаление узла.


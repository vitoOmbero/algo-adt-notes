Экстремальные задачи 㑸 задачи на нахождение оптимальных (максимальных или минимальных) значений.
Решение таких задач ㎨ оптимизация.
Некоторые экстремальные задачи мы можем решить точно, некоторые 㐨 приближённо.

Жадные алгоритмы
- состоят из итераций
- принимают решение на каждом шаге, стараясь найти локально оптимальное решение.

Градиентный спуск
Пример типичного жадного алгоритма.

f(x1, x2, ..., xn) - непрерывная, действительные значения на области определения; определяет поверхность в n-мерном пространстве. Один из алгоритмов минимизации:

1. выбираем начальную точку (x1, x2, ..., xn), она становится текущей точкой алгоритма.
2. обследуя точки вокруг текущей находим такую, в которой f(x1`, x2`, ..., xn`) имеет минимальное значение.
3. если найденная точка отлична от текущей, то делаем её текущей и переходим ко второму шагу алгоритма.
4. end.

f (x, y) = (x − 3)^2 + (y + 2)^2
Начальная точка (x0 = 0, y0 = 0). Шаг поиска 0.1.
Осматриваем окрестности начальной точки.
f (0, 0) = 3^2 + 2^2 = 13
f (0 + 0.1, 0) = 2.9^2 + 2^2 = 8.41 + 4 = 12.41
f (0 − 0.1, 0) = 3.1^2 + 2^2 = 9.61 + 4 = 13.61
f (0, 0 + 0.1) = 9 + 4.41 = 13.41
f (0, 0 − 0.1) = 9 + 3.61 = 12.61
Победила точка (0.1, 0), она становится текущей точкой.


#include <stdio.h>
double f(double x, double y) {
return (x-3)*(x-3) + (y+2)*(y+2);
}
int main() {
double x0 = 0., y0 = 0., d = 0.1;
double dx[] = {d, -d, 0, 0}, dy[] = {0, 0, d, -d};
double newx, newy; bool bestfound = false;
double maxf = f(x0, y0);
while (!bestfound) {
bestfound = true;
for (int i = 0; i < 4; i++) {
double newf = f(x0+dx[i],y0+dy[i]);
if (newf < maxf) {
maxf = newf; bestfound = false;
newx = x0+dx[i]; newy = y0+dy[i];
}
}
if (!bestfound) {
x0 = newx; y0 = newy;
}
}
printf("Best f(%.1f,%.1f)=%.2f\n", x0, y0, maxf);
}

Следующий шаг. Текущая точка (0.1, 0).
Мы выбираем из точек (0.2, 0), (0, 0), (0.1, 0.1), (0.1, −0.1), что
приводит нас к следующей точке (0.2, 0)
Далее маршрут проходит через точки от (0.3,0) до (1,0), затем
попеременно до (3,2).
Решение правильное.

А что произойдёт с решением задачи для функции
(x − 3)2 + 10 sin x + (y + 2)2?
Наш алгоритм выдаст, что лучшим решением будет точка
(-0.7,2) с значением ≈ 7.24, хотя минимум этой функции
достигается в точке (≈ 4.4, −2) с значением ≈ −7.6.


Функция (x − 3)2 + 10sinx + (y + 2)2 имеет несколько
локальных минимумов.
Её линии уровня:

213-01.png

Этот алгоритм, как и все жадные алгоритмы, склонен к нахождению локальных экстремумов.

Жадные алгоритмы не заглядывают вперёд. Они повторяют локально оптимальные по какому-либо критерию шаги и надеются, что решение будет глобпльно оптимальным. Возможно, что найдётся такой локально оптимальный критерий и общее решение окажется верным. Это бывает отнюдь не всегда, но тщательный выбор критерия может найти приемлемое решение.

Формализация условия задачи о рюкзаке
Задача о рюкзаке. Пусть имеется N предметов, стоимость
i−го предмета vi, а масса wi. Найти набор предметов с
наибольшей стоимостью и не превосходящей заданного W
массой.
Приближённое решение Попробуем применить следующий
локально оптимальный алгоритм:
1. Расположим предметы в порядке убывания отношения vi/wi. Пусть они образуют упорядоченное множество B.
2. Установим оставшийся вес L = W
3. Установим множество S = ∅.
4. Выбираем первый предмет I из упорядоченного
множества, вес wI которого не превосходит L.
5. Если такого предмета нет, то алгоритм закончен.
6. Кладём предмет в рюкзак, удаляя его из из B:
B ← B − I : L ← L − wI;S ← SI. Переходим к 4-му шагу.

Данный алгоритм приведёт к какому-либо решению.
Рассмотрим пример:
N = 3
W = 40
w1 = 10;v1 = 60
w2 = 20;v2 = 100
w3 = 20;v3 = 100
Алгоритм выберет последовательно первый и второй
предметы. Их суммарная стоимость окажется 160.
Верное решение - выбрать второй и третий предметы. Их
суммарная стоимость будет 200.


Сжатие информации. Алгоритм Хаффмана.

Задача 4. Имеется текст, состоящий из символов.
Закодировать его таким образом, чтобы:
- каждый из встречающихся символов получил свой двоичный код
- множество кодов было префиксным
- суммарная длина всех кодов для всех символов была бы минимальной.

Пример: пусть имеется текст, состоящий из множества из четырёх символов:
AAAABAABABABABCBCAAAD
Его длина - 21 символ.
Можно закодировать его следующим образом:
- A → 00
- B → 01
- C → 10
- D → 11
На кодирование каждого символа понадобится ровно два бита и общая длина кода составит 42 бита.

Префиксный код
Неформальное определение: код, в котором не имеется кодовых слов, начинающихся с других кодовых слов.
Формальное определение: если существует код со строкой a, то кодов с непустой строкой ab не существует.
Пример: код
 A → 00
 B → 10
 C → 01
 D → 101
префиксным не является, так как кодовое слово символа D начинается с кодового слова символа B.
Другое название: безпрефиксный.
Ещё одно название - код, удовлетворяющий условиям Фано.
Наша задача - найти минимальный префиксный код для множества.


Кодирование с помощью дерева
Ещё раз рассмотрим равномерный код из четырёх символов
  A → 00
  B → 01
  C → 10
  D → 11
Попробуем представить его в виде двоичного дерева.

213-02.png

Алгоритм Хаффмана
AAAABAABABABABCBCAAAD
Определим частоты символов:
  FA = 12
  FB = 6
  FC = 2
  FD = 1
Нужно построить дерево, вес которого минимален.
Sum|i=1..n|( Fi · Li ) , где Li - глубина i−го символа.

Свойства оптимального дерева:
  Из каждого узла должно исходить ровно два пути.
  Не должно быть пустых вершин.
  Самое длинное кодовое слово должно быть парным.

213-03.png


Находим два самых редких символа.

213-04.png

Два самых редких символа должны находиться на самой
длинной ветке. Если нет, то можно их поменять местами с
символами на самой длинной ветке.

213-05
213-06


Жадный алгоритм:
1. Помещаем в каждый узел частоту символа
2. Располагаем узлы согласно убыванию частот.
3. Для двух узлов с наименьшей частотой добавляем узел,
который их соединяет.
4. В узел помещаем сумму частот детей
5. Помечаем узлы или вершины, как уже обработанные
(отправляем вниз)
6. Если необработанных не осталось, то конец алгоритма
7. Переходим к шагу 2.

После шага 1
213-07

Шаги 2,3,4
213-08

Шаг 5
213-09

Следующая итерация:
213-10

Заключительное состояние:
213-11

Получившиеся коды:
 A → 0
 B → 10
 C → 110
 D → 111
Общая длина всех кодовых слов
12 · 1 + 6 · 2 + 2 · 3 + 1 · 1 = 31 < 42


Задача о покрытии строки

Рассмотрим следующую задачу:

Имеется набор строк si, i = 1 ... N - словаа, каждое из которых не начинается с другого (префиксный код).
Имеется длинная строка p.
Требуется определить, можно ли составить слово p из слов si.

Например, если слова si = {ab, ca, ra, dab}, то строку abracadabra из них составить можно:
 ab + ra + ca + dab + ra; а вот слова barca, abracadabraa - нет.

Цель задачи - не просто найти решение, а найти оптимальное решение.
Главные параметры алгоритма:
  N - длина строки p.
  M - сумма длин строк si.
Решается ли эта задача жадным алгоритмом?


Жадный алгоритм:
1. Устанавливаем указатель позиции на начало длинной строки
2. Выбираем слово, которое полностью совпадает с подстрокой, начинающейся с указателя
3. Если такого слова не найдено, выводим ᑐнетᑐ, завершение алгоритма
4. Если такое слово есть, перемещаем указатель на длину слова.
5. Если слово закончилось, то выводим ᓰдаа и завершаем алгоритм
6. Возвращаемся к пункту 2

213-12

Этап 1. Нашли первое слово.
213-13

Этап 2.Переместили указатель и нашли второе слово.
213-14

Этап 3. Переместили указатель и нашли третье слово.
213-15

Оценка сложности алгоритма

C A B B A C A A C A B A B A C C A B

N = 18

A B A C
A B B A
B A C A
C A B
A C A B

K слов общей длиной M
K = 5
M = 19

 Определить, что слово подошло, мы можем только просмотрев всё слово.
 Определить, что слово не подошло, можно даже с первого символа слова.
 Грубо оценим количество попыток на слово длины L как L/2
 Средняя длина слова есть L = M/K
 При одном этапе поиска мы в среднем перебираем K/2 слов, каждое средней длиной L.
  Каждый этап продвигает нас в среднем на L позиций в длиннойй строке, итого количество этапов T = N/L
Итого F = N/L * K/2 * L/2 = N*K/4 = O(N*K) (не зависит от длины слов)

Допустим, K = 1, т.е. ищем покрытие ровно одним словом длины M. N (:.) M
Тогда каждый успешный поиск продвигает нас по длинной строке на M позиций. 
Всего наибольшее количество поисков N/M, в каждом из которых сравнивается M символов.
Тогда F = O(N)

Для большого K алгоритм становится неэффективен. Имеется ли более короткое решение?

Исследование задачи для поиска другого алгоритма
 Для большого K алгоритм становится неэффективен.
 Имеется ли более короткое решение?
 Да, если мы изменим структуру данных.
 Проблема в том, что мы, обнаружив несовпадение с одной подстрокой, ничего не получаем для следующих.
 Усложним представление тех строк, которые мы ищем.
 Попробуем производить поиск параллельно по всем подстрокам.
 Построим префиксное дерево

213-16

Алгоритм построения префиксного дерева
1. Создаём вершину дерева Ơ узел с пустыми ветвями.
2. Для каждого слова исполняем:
2.1 Устанавливаем указатель в вершину дерева.
2.2 Считываем очередную букву.
2.3 Если текущей узел не содержит нужной ветви, создаём эту
ветвь и пустой узел на ней.
2.4 Переходим в нужную ветвь.
2.5 Если узел уже серый или не пустой, завершаем алгоритм с
неудачей.
2.6 Если слово закончилось, то помечаем узел серым цветом.
2.7 Переходим к 2.2
3. Завершаем алгоритм с успехом.

Оценка сложности алгоритма
㝘 Один шаг алгоритма продвигает нас на ровно один символ
в образце.
㩈 Повторно образцы не обрабатываются.
㨸 Количество операций есть O(M), где M 㨸 сумма длин
образцов.

 Поиск по получившемуся дереву стал совсем простым:
C A B B A C A A C A B A B A C C A B

Алгоритм поиска по префиксному дереву
1. Устанавливаем указатели на начало строки и на вершину
дерева.
2. Если указатель стоит за последним символом в строке то:
2.1 Если указатель в дереве находится в корне 鏸 алгоритм
завершён с успехом.
2.2 Иначе алгоритм завершён с неудачей.
3. Считываем очередной символ строки и передвигаем
указатель.
4. Если такой ветви дерева нет 駸 завершаем алгоритм с
неудачей.
5. Переходим по дереву по соответствующей ветке.
6. Если мы попали в серый узел 釨 возвращаемся в корень
дерева.
7. Переходим к пункту 2.


Оценка сложности алгоритма поиска
㤨 Каждое перемещение символа в исходной строке приводит к перемещению указателя в дереве.
㫈 Сложность каждого перемещения постоянна (O(1)).
㞈 Количество перемещений в случае успеха равно N, где N-длина строки.
㟘 Сложность алгоритма поиска 㝘 O(N).
㤈 Общая сложность алгоритма 㢸 (N + M)
㟈 Сложность первой версии алгоритма 㟨 O(N × K).


Абстракция строка символов.

Строка символов
Работа со строками символов 㑈 необходимая часть
интерфейса программы с пользователем.
Строки нужны для:
㖈 вывода информации на экран
㛸 именования внешних объектов 㚨 файлов, компьютеров,
сетевых ресурсов
Главная проблема 㛘 динамически изменяемый размер.
Как считать строку неизвестной заранее длины?
㗨 не разрешать пользователям работать с длинными
строками?
㚸 зарезервировать под неё место определённого размера?
㗨 вводить посимвольно и расширять строку?


Что нам хотелось бы от строк:
㊈ отсутствие ограничений на размер и содержание
㏨ удобные способы ввода и вывода
㏘ интерфейс с операционной системой. Если требуется имя
файла, то строка должна его предоставить в требуемом
виде
㗨 операции сложения строк с собой и с одиночными
символами
⾨ определение размера строки
⿈ выделение подстроки


Абстракция строка символов
Интерфейс абстракции строка символов
 =  присвоение строки другой
 +=  добавить символ или строку в конец
 []  получение символа из строки
 size  получить размер
 substr  вырезать подстроку
 c_str  получить представление строки для системы
Символы строки представляются своими кодами в какой-либо кодировке. (code point)

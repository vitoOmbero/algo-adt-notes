HDD и SSD используют буферизацию для ускорения работы. Алгоритмы поиска во внешней памяти должны минимизировать число обращений к внешней памяти. Пусть имеется бинарное дерево поиска, состоящее из:
1. Данных размером 64 байта.
2. Ключа размером 8 байт.
3. Указателей left и right размером 8 байт.
 Общий размер узла - 88 байт.
 В оперативную память размером 16 гибибайт поместится ≈ 195 × 106 узлов.
 Как хранить словарь из 109 элементов?


B-деревья
 B-дерево - сбалансированной дерево поиска, узлы которого хранятся во внешней памяти.
 В оперативной памяти хранятся часть узлов.

214-01

 Высота дерева не более O(log N), где N - количество узлов.
 Каждый узел может содержать 1 ключ и больше. Количество детей узла равно K + 1, где K - количество ключей в узле

214-02

 Пусть в узле помещается 128 ключей.
 Высота дерева  3
 Тогда общее количество узлов
1 + 129 + 1292 = 16771 Общее количество ключей
16771 × 128 = 2146688

 B-дерево - корневое дерево, обладающее свойствами:
1. Каждый узел содержит:
- количество ключей n, хранящихся в узле.
- индикатор листа ﬁnal.
- n ключей в порядке возрастания.
- n + 1 указатель на детей, если узел не корневой.
2. Ключи есть границы диапазонов ключей в поддеревьях.
3. Все листья расположены на одинаковой глубине h.
4. Имеется показатель t - минимальная степень дерева.
5. В корневом узле от 1 до 2t − 1 ключей.
6. Во внутренних узлах минимум t − 1 ключей.
7. Во внешних узлах максимум 2t − 1 ключей.
8. Заполненный узел имеет 2t − 1 ключ


Теорема: Высота B-дерева с n >= 1 ключами и минимальной степенью t >= 2 в худшем случае не превышает log<sub>t</sub> (n + 1)/2

 Доказательство. В максимально высоком дереве высоты h в каждом узле, кроме корневого, содержится t − 1 ключ.
Тогда общее количество ключей в дереве есть
1 + 2 + 2⋅t + 2⋅t^2 + ... + 2⋅t^(h-1) = 1 + 2⋅(t-1)(1 + t + t^2 + ... + t^(h-1)) = 1 + 2⋅(t-1)⋅( (t_h - 1) / (t - 1));
Отсюда h = log<sub>t</sub> (n+1)/2

B-деревья: операции
- Используем операции Load и Store.
- Корень сохраняем в оперативной памяти.
- Минимизируем количество операций.

B-деревья: операция ﬁnd поиска ключа k

1. Операцией бинарного поиска ищем самый левый ключ key<sub>i</sub> >= k
2. Если key<sub>i</sub> = k, то узел найден.
3. Исполняем Load для дочернего узла и рекурсивно повторяем операцию.
4. Если ﬁnal = true, то ключ не найден.
Количество операций T<sub>load</sub> = O(h) = O(log<sub>t</sub> n)

Добавление ключа
1. Операцией ﬁnd находим узел для вставки.
2. Если лист не заполнен, сохраняя упорядоченность вставляем ключ.
3. Если лист заполнен (2t-1 ключей), разбиваем его на два листа по t-1 ключу поиском медианы.
4. Медиана рекурсивно вставляется в родительский узел.
Сложность в худшем случае: каждый раз разбивается узел на каждом уровне, O(t⋅log<sub>t</sub> n)
Количество операций: Text = O(h) = O(log<sub>t</sub> n)

Разновидности B-деревьев
- B+-дерево содержит информацию только в листьях,
ключи только во внутренних узлах.
- Используется в файловых системах XFS, JFS, NTFS, Btrfs, HFS, ...
- Используется для хранения индексов в базах данных Oracle, Microsoft SQL, IBM DB2, Informix, ...

Обобщённый быстрый поиск


Абстракция отображение (Map)

Интерфейс абстракции отображение как ассоциативного массива.
- **m[key] = value** - добавить элемент с ключом key и значением value
- **value = m[key]** - найти элемент с ключом key и вернуть его.
- **m[key] = nil** - удалить элемент с ключом key
- **for (auto x: m)** - получить все ключи (или все пары ключ/значение) в каком-либо порядке.


Алгоритм Худшее время Среднее время
операция
BST: Вставка O(N log N) O(N log N)
BST: Поиск O(N log N) O(N log N)


 Требуется:
 Уменьшить амортизационную стоимость поиска
 Уменьшить функцию (например, O(log N) → O(log log N))


 База данных названий городов и их численности.

214-03

33 связных списка.

База данных названий городов и их численности.


214-04

33 сбалансированных дерева


- Основная идея - разбиение пространства ключей на независимые подпространства (partitioning).
- При независимом разбиении на M подпространств сложность уменьшается.
Для разбиения множества N ключей на примерно равные M подмножеств сложность вычисляется по главной теореме о рекурсии при числе подзадач M, коэффициенте размножения 1 и консолидации O(1).

C · O(N) → C/M · O(N)

C · O(N·logN) → C/M · O(N·log N)

При увеличении M
 lim<sub>K→∞</sub> T(N,M) = O(1)
lim<sub>K→∞</sub> Mem(N,M) = ∞


 Имеется зона оптимальности при M ≈ N

Требуется иметь детерминированный способ разбиения
пространства ключей на M независимых подпространств.
� Условия разбиения:
|K1| ≈ |K2| ≈ · · · ≈ |KM|
M
Sum|i=1..M|( |Ki| ) = |K|
ퟐ Эврика! Создаём функцию H(K), удовлетворяющую
некоторым условиям.

Хеш-поиск
ଠ Функция преобразования:
H(K) → V
|D(V)| = M
Требуемые свойства:
ఐ Эффективность.
T(H(K)) <= O(L(K)),

где L(K) ୰ мера длины ключа K.
଀ Равномерность. Каждое выходное значение равновероятно.
p_H(K1) = p_H(K2) = · · · = p_H(KM)
ะ Лавинность. При изменении одного бита во входной
последовательности изменяется значительное число
выходных битов.

Следствия их требуемых свойств.
큐 Функция не должны быть непрерывной. Для близких
значений аргумента должны получаться сильно
различающиеся результаты.
펰 В значениях функции не должно образовываться
кластеров, множеств близко стоящих точек.
Определение непрерывности для дискретных функций может
быть дано неформально.


Примеры плохих функций:
৐ H = K^2 mod 10000 для K < 100
Функция монотонно возрастает.
ઐ H = Sum|i=0..s.size()−1|( s[i] ) для строки s.
Функция даёт одинаковые значения для строк abcd и abdc и отличающиеся на единицу для строк abcd и abde.

Не столь отвратительная функция h = Sum|i=0..n|( s[i]·8^i ) mod HASHSIZE

Схема Горнера:
unsigned
hash_sum(string s, unsigned HASHSIZE)
{
unsigned sum = 0;
for (size_t i = 0; i < s.size(); i++) {
sum <<= 3;
sum += s[i];
}
return sum % HASHSIZE;
}


 Хеш-функция получше
unsigned
hash_sedgwick(string s, unsigned HASHSIZE)
{
unsigned h, i, a = 31415, b = 27183;
for (h = 0, i = 0; i < s.size();
i++, a = a * b % (HASHSIZE-1)) {
h = (a * h + *v) % HASHSIZE;
}
return h;
}



Лучшие по статистическим показателям функции ධ
криптографические.
เ Недостатки:
຀ длинный код
຀ медленные


 Очень хорошие хеш-функции.
ꏠ Применяется полиномиальная арифметика или
арифметика полей Галуа.
ꐐ В полях Галуа определены операции сложения и
умножения.
ꏀ Пример: операции в поле GF(2^3), оно состоит из чисел 0 ... 7
ꉰ Операция сложение есть побитовое исключающее или XOR.

Для умножения требуется число представить как полином.
5 = 101_2 = 1 · x^2 + 0 · x^1 + 1 · x^0 = x^2 + 1
횠 Умножение чисел есть умножение полиномов.
5 ∗ 5 = (x^2 + 1) · (x^2 + 1) = x^4 + x^2 + x^2 + 1 = x^4 + 1 = 17
홠 Но ведь 17 не входит в поле GF(2^3).
훰 Вводится понятие производящий полином, который
должен быть неприводимым, то есть, не должен иметь
полиномов-делителей, отличных от него и единицы.
흀 Один из таких полиномов для GF(2^3) есть x^3 + x + 1.
ퟀ Результатом умножения будет остаток от деления x^4 + 1
на производящий полином x^3 + x + 1, что будет равно
x^2 + x + 1 = 7

ꄰ P(x) - исходное сообщение длины M битов
ꃀ G(x) - производящий полином длины N битов
ꄐ R(x) есть остаток от деления P(x) на G(x) в GF(2^N)
ꄐ Длина R(x) ровно N битов.
ꃐ Если производящий полином G(x) неприводим, то
множество R(x) имеет мощность 2^N.
Для GF(2^32 один из неприводимых полиномов
x^32+x^26+x^23+x^22+x^16+x^12+x^11+x^10+x^8+x^7+x^6+x^4+x^2+x+1


 Примитивный член поля GF(2^N) есть тот, степени
которого содержат все ненулевые элементы поля.
꜐ Алгоритм умножения чисел становится элементарным.
Ꙡ Составляется таблица степеней примитивного члена.
Ʞ Например, для GF(2^3) 2^6 = 5. Тогда
5 · 5 = 2^6 · 2^6 = 2^12 = 2^(12 mod 7) = 2^5 = 7

Сама функция:
uint32 hash(uchar *ptr, unsigned length) {
uint32 c = 0xFFFFFFFF;
while (length) {
c ^= (uint32) (ptr[0]);
c = (c >> 8) ^ _table[c & 0xFF];
ptr++;
length--;
}
return c ^ 0xFFFFFFFF;
}

Распределение значений для случайных идентификаторов.
Плохая функция
214-05
214-06

Хорошая функция.
214-07
214-08

Отличная функция.
214-09
214-10

Затраты времени на исполнение хеш-функций
Алгоритм/набор include.txt source.txt
hash_sum 890 786
hash_segewick 2873 2312
hash_crc 912 801


Синхронизация больших объектов
Условия применения:
ῠ Синхронизируемый объект имеет значительный размер
ᾀ Объект регулярно изменяет своё содержимое
῰ Размер изменяемой зоны относительно невелик
Обычное копирование расходует ресурс: пропускную способность.

Два паттерна использования:
1. первичная пересылка объекта. Может потребовать передачи полного объёма.
2. пересылка изменённых фрагментов.

Задача: клиент синхронизирует большой объект с сервера.
Условия: на клиенте и сервере имеются реплики большого объекта, возможно, уже изменившегося на сервере.
Используется одна и та же хеш-функция.

1. клиент и сервер разбивают объект на (виртуальные) блоки. Для каждого блока подсчитывается хеш.
2. клиент передаёт серверу номера блоков, для которых нужно вычислить хеш
3. сервер передаёт хеш запрошенных блоков
4. клиент сравнивает хеш и обнаруживает блоки с несовпадающем хешем
5. клиент запрашивает блоки с несовпадающем хешем

Хеш-таблицы

Простая хеш-таблица

214-11

Простая хеш-таблица, обычная реализация в виде массива указателей
214-12

- Известно количество элементов в контейнере C
- Известен размер массива M
- α = C/M  -  коэффициент заполнения, fill-factor, load-factor.
- α - главный показатель хеш-таблицы.

Операция создания хеш-таблицы

214-13

Операция создания хеш-таблицы требует операцию поиска.
214-14

Коллизии нежелательны. Без коллизий сложность операций поиска и вставки равна O(1)

- Hash("Якутск") = 2
- Hash("Мышкин") = 2

Способы борьбы с коллизиями:

- Прямая или закрытая адресация
- Открытая адресация
- Рехеширование

Хеш-таблицы с прямой адресацией
- При коллизии во время создания элемента создаётся связный список конфликтующих.
- Технически можно создать любую поисковую структуру данных
214-15

1. При поиске вычисляется хеш-функция.
2. Определяется место поиска - вторичная поисковая структуре данных.
3. Если вторичной структуры нет, то нет и элемента.
4. Иначе элемент ищется во вторичной структуре.

1. При удалении вычисляется хеш-функция.
2. Определяется место поиска - вторичная поисковая структуре данных.
3. Если вторичной структуры нет, то нет и элемента.
4. Иначе элемент удаляется из вторичной структуре.
5. Если вторичная структура пуста, удаляет точку входа.

Хеш-таблицы с открытой адресацией
- Другой способ поиска - искать в той же таблице повторно
214-16

1. При поиске существующего вычисляется хеш-функция.
2. Определяется место поиска - индекс в хеш-таблице.
3. Если по индексу ничего нет, то нет и элемента.
4. Иначе по индексу - элемент с нашим ключом - элемент найден.
5. Если по индексу - элемент с другим ключом или элемент помечен удалённым, индекс увеличиваем на единицу и переходим к пункту 3.
6. Следующий индекс вычисляется по формуле (index + 1) mod M.

1. При вставке вычисляется хеш-функция.
2. Определяется место поиска - индекс в хеш-таблице.
3. Если по индексу ничего нет или элемент помечен удалённым, то вставляем по индексу и выходим.
4. Если по индексу элемент с нашим ключом - меняем данные и выходим.
5. Если по индексу элемент с другим ключом то индекс увеличиваем на единицу и переходим к пункту 3.
6. Следующий индекс вычисляется по формуле (index + 1) mod M.

1. Почему мы требуем свойства равномерности от хеш-функции.
214-17

1. При удалении вычисляется хеш-функция.
2. Определяется место поиска - индекс в хеш-таблице.
3. Если по индексу ничего нет, то нет и элемента.
4. Иначе по индексу - элемент с нашим ключом - элемент найден.
5. Если по индексу - элемент с другим ключом, индекс увеличивается на единицу и переходим к пункту 3.
6. Следующий индекс вычисляется по формуле (index + 1) mod M.

Расширение хеш-таблиц

Когда fill-factor начинает превосходить 0.7-0.8 таблицу расширяют.
- Создаётся другой массив указателей с нужным размером
- Из оригинального массива в порядке увеличения индексов извлекаются элементы и вставляются в новый массив (таблицу).
- Старый массив удаляется.

Подсчёт амортизационных расходов.
- Амортизационные расходы на закрытую адресацию
- Амортизационные расходы на открытую адресацию
- Амортизационные расходы на рехеширование
Рехеширование уменьшает потребность в памяти.
Открытые обычно быстрее

Рекомендации по использованию.
1. Всегда использовать хорошую хеш-функцию!
2. Использовать fill-factor не больше 0.5-0.6.


Параллельное использование алгоритмов поиска. Списки с cпропусками.

 При параллельном программировании к одному элементу данных может обратиться несколько потоков.
 Результат при этом может быть недетерминирован.

int a = 0, b = 0;
//thread 1
b = 2;
a = b + 1;
//thread 2
a = 4;
b = a - 3;


 Критерий Бернстайна: Поместим объекты, которые
читаются в потоке i в множество Ri, а те, которые
пишутся, в множество Wi.
梸 Для нашего кода R1 = {b}, W1 = {a,b}, R2 = {a},
W2 = {a,b}.
桘 Критерий гласит, что если все пересечения множеств
R1 ∩ W2, R2 ∩ W1, W1 ∩ W2 пусты, то конфликтов (race
conditions) не возникнет.
娨 В нашем случае: R1 ∩ W2 = {a}, R2 ∩ W1 = {a},
W1 ∩ W2 = {a, b}, то есть race conditions возможны.


 Одно из средство избежать race conditions 鰸
использование атомарных операций.
鯸 Существуют машинные команды типа Compare-And-Swap,
исполняющиеся атомарно.
髈 Они позволяют атомарно обменять две ячейки памяти,
которые, возможно, содержат указатели.
鲸 При вставке в односвязный список достаточно атомарных
операций для замены цепочки указателей.
鯨 Односвязный список 骨 идеальная структура данных для
параллельного программирования.


 Операция поиска в односвязном списке T() = O(N)
棨 Операции вставки и удаления в односвязном списке
T() = O(N)
嫘 Требуется по возможности сохранить свойства операций
вставки и удаления в лучшем случае и ускорить операцию
поиска.

Списки с пропусками
Рассмотрим следующую структуру данных:

214-18

 Она представляет из себя несколько списков,
организованных в виде списков.
锘 Каждый следующий список примерно в два раза короче
предыдущего и он пропускает примерно половину
элементов предыдущего.


 Поиск существующего элемента.
214-19

Поиск несуществующего элемента.
214-20

 Вставка элемента.
214-21

 Удаление элемента. Поиск и пометка столбца.
214-22

 Удаление элемента. Удаление из строк.
214-23

Удаление элемента. Заключительное удаление.
214-24

Вставка 10^6 элементов в структуру данных.
Укладывание Array RBTree SkipList
Случайно 127033 ms 1020 ms 1737 ms
По возрастанию 108 ms 457 ms 536 ms
По убыванию 256337 ms 358 ms 407 ms

Амортизационная сложность списков с пропусками:
- Вставка - T(N) = O(log N)
- Поиск - T(N) = O(log N)
- Удаление - T(N) = O(log N)

Практическое использование АСД

Практическое использование: задача триангуляции
- Требуется соединить все точки между собой так, чтобы сумма периметров полученных треугольников была минимальной.

214-25
214-26
214-27
214-28
214-29
214-30
214-31
214-32
214-33
214-34
214-35
214-36
214-37
214-38
214-39
214-40

Требуемые для решения задачи структуры данных.
- Сами точки. Массив.
- Связи между точками. Свойства: После начальной разбивки размер не изменяется

ꙸ Связи, которые требуется проверить (чёрные)
- Повторения не допускаются
- Можно выбирать в любом порядке
- Размер не превосходит общего количества связей

Вершины двух треугольников, для которых связь является основанием.
- Совпадает с количеством связей
- Изменяется при изменении топологии

 Связь
錘 вершины двух опорных треугольников
鎈 чёрная/зелёная
鍨 Замена чёрной связи (2,4) на зелёную (1,3)
駨 Теперь связи (1,2), (2,3), (1,4), (3,4) 飈 чёрные.
鋘 Надо их быстро найти, пометить их чёрными и поместить
в множество на обработку.
鉈 Надо удалить связь (2,4 ) и создать связь (1,3)

214-41

껸 Точки: массив N.
꿸 Связи: хеш-таблица.
깈 Размер Θ(N) не изменяется.
껸 Частый поиск.
꼈 Более редкое изменение.
께 Хеш-таблица связей.
깈 Приоритетная очередь связей на обработку.


